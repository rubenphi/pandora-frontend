<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Detector OMR en Tiempo Real</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f5f5f5;
        overflow-x: hidden;
      }
      .container {
        margin: 0 auto;
        padding: 10px;
      }
      .video-and-controls-wrapper {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }
      .video-container {
        max-width: 400px;
        max-height: 300px;
        margin: 0;
        background: #000;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #ccc;
      }
      #video {
        display: none;
      }
      #canvasOutput {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
      }
      canvas {
        display: block;
      }
      .contrast-slider-container {
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        margin-top: 20px;
      }
      .contrast-slider-container label {
        white-space: nowrap;
        margin-top: 10px;
      }
      .contrast-slider-container input[type="range"] {
        width: 200px;
        height: 20px;
        -webkit-appearance: none;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 5px;
      }
      .contrast-slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
      .contrast-slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ“¹ Detector OMR - Vista Binaria</h1>
      <div id="status">Cargando OpenCV.js...</div>

      <div class="controls">
        <button id="stopBtn" class="stop" disabled style="display: none">
          Detener
        </button>
        <button id="retryBtn" disabled style="display: none">Reintentar</button>
      </div>

      <div class="video-and-controls-wrapper">
        <div class="video-container">
          <video
            id="video"
            autoplay
            playsinline
            width="640"
            height="480"
            style="display: none"
          ></video>
          <canvas id="canvasOutput" width="640" height="480"></canvas>
        </div>

        <div class="contrast-slider-container">
          <label
            >Contraste:
            <input id="contrast" type="range" min="0" max="200" value="100"
          /></label>
          <label style="margin-top: 8px"
            >Debug orientaciÃ³n: <input id="debugOri" type="checkbox"
          /></label>
        </div>
      </div>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.5.2/opencv.js"
      onload="onOpenCvReady()"
    ></script>

    <script>
      function onOpenCvReady() {
        startCamera();
      }

      function startCamera() {
        const video = document.getElementById("video");
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
              video.play();
              initOpenCV();
            };
          })
          .catch((err) => console.error(err));
      }

      function initOpenCV() {
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvasOutput");
        const ctx = canvas.getContext("2d");

        const width = video.videoWidth;
        const height = video.videoHeight;
        canvas.width = width;
        canvas.height = height;

        let src = new cv.Mat(height, width, cv.CV_8UC4);
        let gray = new cv.Mat(height, width, cv.CV_8UC1);
        let bw = new cv.Mat(height, width, cv.CV_8UC1);

        const contrastInput = document.getElementById("contrast");
        let contrastValue = parseFloat(contrastInput.value) / 100.0;
        contrastInput.oninput = () => {
          contrastValue = parseFloat(contrastInput.value) / 100.0;
        };
        contrastInput.addEventListener(
          "touchmove",
          (e) => {
            e.stopPropagation();
            e.preventDefault();
          },
          { passive: false }
        );

        let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
        let captured = false;
        let matrixTemplate = null;
        // user-supplied circle template (percentages relative to template rectangle)
        // values provided: percent_x and percent_y (0-100)
        let circleTemplate = {
          rectangle: {
            top_left: { x: 5.597393, y: 5.0 },
            top_right: { x: 114.357054, y: 5.0 },
            bottom_left: { x: 5.597393, y: 74.089405 },
            bottom_right: { x: 114.357054, y: 74.089401 },
            width: 108.759661,
            height: 69.089401,
          },
          circles: {
            CTL: { percent_x: 8.05, percent_y: 7.9 },
            CTR: { percent_x: 31, percent_y: 7.9 },
            CBL: { percent_x: 8.05, percent_y: 43 },
            CBR: { percent_x: 31, percent_y: 43 },
          },
        };
        // try to fetch the SVG template with matrix definition (matrizCode.txt)
        fetch("matrizCode.txt")
          .then((r) => r.text())
          .then((txt) => {
            try {
              // parse viewBox if present
              let vbMatch = txt.match(
                /viewBox\s*=\s*"([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)"/i
              );
              let vw = 1,
                vh = 1;
              if (vbMatch) {
                vw = parseFloat(vbMatch[3]);
                vh = parseFloat(vbMatch[4]);
              } else {
                // fallback: try width/height
                let wMatch = txt.match(/width\s*=\s*"([\d.]+)mm"/i);
                let hMatch = txt.match(/height\s*=\s*"([\d.]+)mm"/i);
                if (wMatch && hMatch) {
                  vw = parseFloat(wMatch[1]);
                  vh = parseFloat(hMatch[1]);
                }
              }

              const points = [];
              const ellRe =
                /<ellipse[^>]*cx\s*=\s*"([\d.\-]+)"[^>]*cy\s*=\s*"([\d.\-]+)"/gi;
              let m;
              while ((m = ellRe.exec(txt))) {
                const cx = parseFloat(m[1]);
                const cy = parseFloat(m[2]);
                points.push({ u: cx / vw, v: cy / vh, cx, cy });
              }

              // parse marker groups: transform="translate(x,y)" plus inner rects
              const groupRe =
                /<g[^>]*transform\s*=\s*"translate\(([\d.\-]+)\s*,\s*([\d.\-]+)\)"[^>]*>([\s\S]*?)<\/g>/gi;
              const rectRe =
                /<rect[^>]*x\s*=\s*"([\d.\-]+)"[^>]*y\s*=\s*"([\d.\-]+)"[^>]*width\s*=\s*"([\d.\-]+)"[^>]*height\s*=\s*"([\d.\-]+)"/i;
              const markerGroups = [];
              while ((m = groupRe.exec(txt))) {
                const gx = parseFloat(m[1]);
                const gy = parseFloat(m[2]);
                const inner = m[3];
                const r = rectRe.exec(inner);
                if (r) {
                  const rx = parseFloat(r[1]);
                  const ry = parseFloat(r[2]);
                  const rw = parseFloat(r[3]);
                  const rh = parseFloat(r[4]);
                  const cx = gx + rx + rw / 2;
                  const cy = gy + ry + rh / 2;
                  markerGroups.push({ cx, cy, gx, gy });
                }
              }

              let templateMarkers = null;
              if (markerGroups.length >= 6) {
                const sortedByY = markerGroups
                  .slice()
                  .sort((a, b) => a.cy - b.cy);
                const topCandidates = sortedByY
                  .slice(0, 3)
                  .sort((a, b) => a.cx - b.cx);
                const bottomCandidates = sortedByY
                  .slice(-3)
                  .sort((a, b) => a.cx - b.cx);
                templateMarkers = [
                  topCandidates[0],
                  topCandidates[1],
                  topCandidates[2],
                  bottomCandidates[0],
                  bottomCandidates[1],
                  bottomCandidates[2],
                ];
              }

              if (points.length > 0) {
                let umin = Math.min(...points.map((p) => p.u));
                let umax = Math.max(...points.map((p) => p.u));
                let vmin = Math.min(...points.map((p) => p.v));
                let vmax = Math.max(...points.map((p) => p.v));
                matrixTemplate = {
                  vw,
                  vh,
                  points,
                  umin,
                  umax,
                  vmin,
                  vmax,
                  templateMarkers,
                };
                console.log("matrixTemplate loaded: ", matrixTemplate);

                if (templateMarkers && templateMarkers.length === 6) {
                  // compute corner weights for CTL,CTR,CBL,CBR relative to the 6 template markers
                  function computeWeightsForPoint(px, py, markers) {
                    const m6 = markers[5];
                    const B = Array.from({ length: 5 }, () => [0, 0]);
                    for (let i = 0; i < 5; i++) {
                      B[i][0] = markers[i].cx - m6.cx;
                      B[i][1] = markers[i].cy - m6.cy;
                    }
                    const y = [px - m6.cx, py - m6.cy];
                    const BtB = Array.from({ length: 5 }, () =>
                      Array(5).fill(0)
                    );
                    const BtY = Array(5).fill(0);
                    for (let i = 0; i < 5; i++) {
                      for (let j = 0; j < 5; j++) {
                        BtB[i][j] += B[i][0] * B[j][0] + B[i][1] * B[j][1];
                      }
                      BtY[i] += B[i][0] * y[0] + B[i][1] * y[1];
                    }
                    const N = 5;
                    const A = Array.from({ length: N }, (_, r) =>
                      BtB[r].slice()
                    );
                    for (let r = 0; r < N; r++) A[r].push(BtY[r]);
                    for (let i = 0; i < N; i++) {
                      let maxRow = i;
                      for (let k = i + 1; k < N; k++) {
                        if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i]))
                          maxRow = k;
                      }
                      if (Math.abs(A[maxRow][i]) < 1e-9) continue;
                      const tmp = A[i];
                      A[i] = A[maxRow];
                      A[maxRow] = tmp;
                      const diag = A[i][i];
                      for (let j = i; j <= N; j++) A[i][j] /= diag;
                      for (let r = 0; r < N; r++) {
                        if (r === i) continue;
                        const factor = A[r][i];
                        if (Math.abs(factor) < 1e-12) continue;
                        for (let c = i; c <= N; c++)
                          A[r][c] -= factor * A[i][c];
                      }
                    }
                    const w5 = Array(N).fill(0);
                    for (let i = 0; i < N; i++) w5[i] = A[i][N];
                    const w = [];
                    let sum5 = 0;
                    for (let i = 0; i < 5; i++) {
                      w.push(w5[i]);
                      sum5 += w5[i];
                    }
                    w.push(1 - sum5);
                    return w;
                  }

                  const corners = {
                    CTL: null,
                    CTR: null,
                    CBL: null,
                    CBR: null,
                  };
                  if (points.length >= 4) {
                    const midU =
                      (Math.min(...points.map((p) => p.u)) +
                        Math.max(...points.map((p) => p.u))) /
                      2;
                    const left = points
                      .filter((p) => p.u <= midU)
                      .sort((a, b) => a.v - b.v);
                    const right = points
                      .filter((p) => p.u > midU)
                      .sort((a, b) => a.v - b.v);
                    if (left.length >= 2 && right.length >= 2) {
                      corners.CTL = left[0];
                      corners.CBL = left[left.length - 1];
                      corners.CTR = right[0];
                      corners.CBR = right[right.length - 1];
                    } else {
                      const minU = points.reduce((a, b) => (a.u < b.u ? a : b));
                      const maxU = points.reduce((a, b) => (a.u > b.u ? a : b));
                      const minV = points.reduce((a, b) => (a.v < b.v ? a : b));
                      const maxV = points.reduce((a, b) => (a.v > b.v ? a : b));
                      corners.CTL = minU;
                      corners.CBR = maxU;
                      corners.CBL = maxV;
                      corners.CTR = minV;
                    }
                  }

                  const cornerWeights = {};
                  try {
                    const markerCoords = templateMarkers.map((m) => ({
                      cx: m.cx,
                      cy: m.cy,
                    }));
                    for (const key of ["CTL", "CTR", "CBL", "CBR"]) {
                      const cp = corners[key];
                      if (cp) {
                        const px = cp.u * vw;
                        const py = cp.v * vh;
                        cornerWeights[key] = computeWeightsForPoint(
                          px,
                          py,
                          markerCoords
                        );
                      }
                    }
                    matrixTemplate.cornerWeights = cornerWeights;
                    console.log("computed corner weights", cornerWeights);
                  } catch (err) {
                    console.warn("corner weight computation failed", err);
                  }
                }
              }
            } catch (err) {
              console.warn("Failed to parse matrizCode.txt", err);
            }
          })
          .catch(() => {
            /* ignore missing template */
          });
        let debugMode = false;
        let debugInfo = null;

        const debugCheckbox = document.getElementById("debugOri");
        debugCheckbox.addEventListener("change", (e) => {
          debugMode = !!e.target.checked;
        });

        function loop() {
          ctx.drawImage(video, 0, 0, width, height);
          let imageData = ctx.getImageData(0, 0, width, height);
          src.data.set(imageData.data);

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.convertScaleAbs(gray, gray, contrastValue, 0);
          cv.GaussianBlur(gray, gray, new cv.Size(3, 3), 0);
          clahe.apply(gray, gray);
          cv.threshold(gray, bw, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          // Detect contours
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(
            bw,
            contours,
            hierarchy,
            cv.RETR_TREE,
            cv.CHAIN_APPROX_SIMPLE
          );

          let dst = new cv.Mat();
          cv.cvtColor(bw, dst, cv.COLOR_GRAY2RGBA);

          // Detect normal markers (outer rect with inner rect), compute centroids and label regions
          let markerCount = 0;
          let innerAreas = [];
          let normalMarkers = []; // {outerIdx, innerIdx, innerArea, cx, cy, label}
          let hierArr = null;
          try {
            hierArr = hierarchy.data32S;
          } catch (e) {
            hierArr = null;
          }

          const minArea = Math.max(100, width * height * 0.0005);

          // Expected layout now: top row has 3 markers (TL, TM, TR)
          // bottom row has 3 markers (BL, BM, BR). We'll assign each detected
          // centroid to the nearest expected position to produce labels.
          const topLabels = ["TL", "TM", "TR"];
          const bottomLabels = ["BL", "BM", "BR"];
          const expectedPositions = [];
          for (let i = 0; i < 3; i++)
            expectedPositions.push({
              label: topLabels[i],
              x: ((i + 0.5) * width) / 3,
              y: height * 0.25,
            });
          for (let i = 0; i < 3; i++)
            expectedPositions.push({
              label: bottomLabels[i],
              x: ((i + 0.5) * width) / 3,
              y: height * 0.75,
            });

          // keep track of assigned expected positions
          const assigned = {};

          for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < minArea) continue;
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            if (approx.rows === 4 && cv.isContourConvex(approx)) {
              let childIdx = -1;
              if (hierArr) childIdx = hierArr[i * 4 + 2];
              if (childIdx !== -1) {
                let childCnt = contours.get(childIdx);
                let childArea = cv.contourArea(childCnt);
                if (
                  childArea > 0 &&
                  childArea / area > 0.01 &&
                  childArea / area < 0.9
                ) {
                  let cPeri = cv.arcLength(childCnt, true);
                  let cApprox = new cv.Mat();
                  cv.approxPolyDP(childCnt, cApprox, 0.02 * cPeri, true);
                  if (cApprox.rows === 4 && cv.isContourConvex(cApprox)) {
                    // centroid of inner contour
                    let m = cv.moments(childCnt);
                    let cx = 0,
                      cy = 0;
                    if (m.m00 && m.m00 !== 0) {
                      cx = m.m10 / m.m00;
                      cy = m.m01 / m.m00;
                    } else {
                      let r = cv.boundingRect(childCnt);
                      cx = r.x + r.width / 2;
                      cy = r.y + r.height / 2;
                    }

                    // find nearest expected position
                    let best = null;
                    let bestDist = Infinity;
                    for (let k = 0; k < expectedPositions.length; k++) {
                      const ep = expectedPositions[k];
                      const dx = ep.x - cx,
                        dy = ep.y - cy;
                      const d = Math.hypot(dx, dy);
                      if (d < bestDist) {
                        bestDist = d;
                        best = { ep, k, d };
                      }
                    }

                    // threshold: accept if within reasonable distance (~width/6)
                    const acceptTh = Math.max(20, Math.min(width, height) / 6);
                    let regionLabel = null;
                    if (best && best.d <= acceptTh) {
                      // if already assigned, keep the closer one
                      if (!assigned[best.k] || assigned[best.k].dist > best.d) {
                        assigned[best.k] = { idx: i, dist: best.d };
                        regionLabel = best.ep.label;
                      } else {
                        regionLabel = best.ep.label; // still label but duplicates may exist, we'll resolve later
                      }
                    } else {
                      // fallback: use top/bottom third based on x
                      if (cy < height / 2) {
                        if (cx < width / 3) regionLabel = "TL";
                        else if (cx < (2 * width) / 3) regionLabel = "TM";
                        else regionLabel = "TR";
                      } else {
                        if (cx < width / 3) regionLabel = "BL";
                        else if (cx < (2 * width) / 3) regionLabel = "BM";
                        else regionLabel = "BR";
                      }
                    }

                    markerCount++;
                    innerAreas.push(childArea);
                    normalMarkers.push({
                      outerIdx: i,
                      innerIdx: childIdx,
                      innerArea: childArea,
                      cx: cx,
                      cy: cy,
                      label: regionLabel,
                    });

                    cv.drawContours(
                      dst,
                      contours,
                      i,
                      new cv.Scalar(0, 255, 0, 255),
                      2,
                      cv.LINE_8,
                      hierarchy,
                      0
                    );
                    cv.drawContours(
                      dst,
                      contours,
                      childIdx,
                      new cv.Scalar(0, 128, 255, 255),
                      2,
                      cv.LINE_8
                    );
                    cv.putText(
                      dst,
                      regionLabel,
                      new cv.Point(Math.round(cx) - 12, Math.round(cy) - 12),
                      cv.FONT_HERSHEY_SIMPLEX,
                      0.7,
                      new cv.Scalar(255, 255, 255, 255),
                      2
                    );
                  }
                  cApprox.delete();
                }
              }
            }
            approx.delete();
          }

          // Average inner area (use median to be robust)
          let avgInnerArea = 0;
          let medianInnerArea = 0;
          if (innerAreas.length > 0) {
            avgInnerArea =
              innerAreas.reduce((a, b) => a + b, 0) / innerAreas.length;
            // median
            let sorted = innerAreas.slice().sort((a, b) => a - b);
            let mid = Math.floor(sorted.length / 2);
            medianInnerArea =
              sorted.length % 2 !== 0
                ? sorted[mid]
                : (sorted[mid - 1] + sorted[mid]) / 2;
          }

          // Deduplicate markers: if multiple detected markers were assigned the
          // same expected label (e.g., BR twice), keep only the one closest to
          // the expected position. Also include unassigned markers that don't
          // conflict with chosen ones.
          (function dedupeAssignedMarkers() {
            const expectedLabels = expectedPositions.map((e) => e.label);
            const uniqueNormals = [];

            for (let k = 0; k < expectedPositions.length; k++) {
              const ep = expectedPositions[k];
              const candidates = normalMarkers.filter(
                (n) => n.label === ep.label
              );
              if (candidates.length === 0) continue;
              let best = candidates[0];
              let bestD = Math.hypot(best.cx - ep.x, best.cy - ep.y);
              for (let i = 1; i < candidates.length; i++) {
                const c = candidates[i];
                const d = Math.hypot(c.cx - ep.x, c.cy - ep.y);
                if (d < bestD) {
                  best = c;
                  bestD = d;
                }
              }
              uniqueNormals.push(best);
            }

            // Add any other normalMarkers that weren't chosen above (different labels)
            for (const n of normalMarkers) {
              const exists = uniqueNormals.some(
                (u) => u.cx === n.cx && u.cy === n.cy
              );
              if (!exists) {
                // If the label is one of the expected labels but wasn't chosen,
                // skip it; otherwise include it (fallback/labeled by y/x)
                if (!expectedLabels.includes(n.label)) uniqueNormals.push(n);
              }
            }

            normalMarkers = uniqueNormals;
            // update markerCount to reflect deduped normals
            markerCount = normalMarkers.length;
          })();

          // initialize debugInfo to empty each frame
          debugInfo = null;

          // Real-time orientation correction: try 0/90/180/270 rotations of the
          // detected centroids and pick the rotation where the markers split
          // into two rows of 3+3. Then assign labels based on that rotated layout
          // so TL/TM/TR and BL/BM/BR are correctly assigned regardless of camera rotation.
          (function orientAndRelabel() {
            if (!normalMarkers || normalMarkers.length === 0) return;
            const angles = [0, 90, 180, 270];
            const cx0 = width / 2,
              cy0 = height / 2;
            function rotatePointForAngle(x, y, angle) {
              const a = (angle * Math.PI) / 180;
              const rw = angle % 180 === 0 ? width : height;
              const rh = angle % 180 === 0 ? height : width;
              const newCx = rw / 2,
                newCy = rh / 2;
              const tx = x - cx0,
                ty = y - cy0;
              const rx = tx * Math.cos(a) - ty * Math.sin(a);
              const ry = tx * Math.sin(a) + ty * Math.cos(a);
              return { x: rx + newCx, y: ry + newCy };
            }

            let bestAngle = null;
            for (let a of angles) {
              const rw = a % 180 === 0 ? width : height;
              const rh = a % 180 === 0 ? height : width;
              const rotated = normalMarkers.map((p) =>
                rotatePointForAngle(p.cx, p.cy, a)
              );
              const topCount = rotated.filter((p) => p.y < rh / 2).length;
              const bottomCount = rotated.length - topCount;
              if (topCount === 3 && bottomCount === 3) {
                bestAngle = a;
                break;
              }
            }

            if (bestAngle === null) {
              // pick best angle minimizing difference from 3/3 split
              let bestScore = Infinity;
              for (let a of angles) {
                const rw = a % 180 === 0 ? width : height;
                const rh = a % 180 === 0 ? height : width;
                const rotated = normalMarkers.map((p) =>
                  rotatePointForAngle(p.cx, p.cy, a)
                );
                const topCount = rotated.filter((p) => p.y < rh / 2).length;
                const bottomCount = rotated.length - topCount;
                const score =
                  Math.abs(topCount - 3) + Math.abs(bottomCount - 3);
                if (score < bestScore) {
                  bestScore = score;
                  bestAngle = a;
                }
              }
            }

            if (bestAngle !== null) {
              const rw = bestAngle % 180 === 0 ? width : height;
              const rh = bestAngle % 180 === 0 ? height : width;
              const rotatedWithIdx = normalMarkers.map((p, idx) => {
                const r = rotatePointForAngle(p.cx, p.cy, bestAngle);
                return { idx, x: r.x, y: r.y, orig: p };
              });

              const topRow = rotatedWithIdx
                .filter((p) => p.y < rh / 2)
                .sort((a, b) => a.x - b.x);
              const bottomRow = rotatedWithIdx
                .filter((p) => p.y >= rh / 2)
                .sort((a, b) => a.x - b.x);

              // choose which row will be considered the logical "top" (3 items)
              let rowTop = topRow,
                rowBottom = bottomRow;
              if (topRow.length !== 3 && bottomRow.length === 3) {
                rowTop = bottomRow;
                rowBottom = topRow;
              }

              // assign labels: top -> TL,TM,TR ; bottom -> BL,BM,BR
              const labelsTop = ["TL", "TM", "TR"];
              const labelsBot = ["BL", "BM", "BR"];
              rowTop = rowTop || [];
              rowBottom = rowBottom || [];
              for (let i = 0; i < rowTop.length && i < labelsTop.length; i++) {
                const entry = rowTop[i];
                normalMarkers[entry.idx].label = labelsTop[i];
              }
              for (
                let i = 0;
                i < rowBottom.length && i < labelsBot.length;
                i++
              ) {
                const entry = rowBottom[i];
                normalMarkers[entry.idx].label = labelsBot[i];
              }

              // Save debug info for overlay drawing
              try {
                debugInfo = {
                  angle: bestAngle,
                  rowTopIdxs: (rowTop || []).map((e) => e.idx),
                  rowBottomIdxs: (rowBottom || []).map((e) => e.idx),
                };
              } catch (err) {
                debugInfo = {
                  angle: bestAngle,
                  rowTopIdxs: [],
                  rowBottomIdxs: [],
                };
              }
            }
          })();

          // No special-marker workflow: we expect 6 equal markers (3 top, 3 bottom)
          cv.putText(
            dst,
            "Marcadores detectados: " + markerCount,
            new cv.Point(10, 30),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 255, 0, 255),
            2
          );

          cv.imshow("canvasOutput", dst);

          // debug overlay: draw rotation info and which markers formed rowTop/rowBottom
          if (debugMode && debugInfo) {
            try {
              ctx.save();
              ctx.fillStyle = "rgba(0,0,0,0.5)";
              ctx.fillRect(8, 72, 260, 60);
              ctx.fillStyle = "#fff";
              ctx.font = "14px monospace";
              ctx.fillText(`rot: ${debugInfo.angle}Â°`, 12, 92);
              ctx.fillText(
                `rowTop indices: [${debugInfo.rowTopIdxs.join(",")}]`,
                12,
                112
              );
              ctx.fillText(
                `rowBottom indices: [${debugInfo.rowBottomIdxs.join(",")}]`,
                12,
                132
              );

              // draw circles on detected centroids: blue = rowTop, orange = rowBottom
              for (let i = 0; i < normalMarkers.length; i++) {
                const nm = normalMarkers[i];
                if (!nm) continue;
                const x = Math.round(nm.cx),
                  y = Math.round(nm.cy);
                if (debugInfo.rowTopIdxs.includes(i))
                  ctx.fillStyle = "rgba(0,150,255,0.9)";
                else if (debugInfo.rowBottomIdxs.includes(i))
                  ctx.fillStyle = "rgba(255,150,0,0.9)";
                else ctx.fillStyle = "rgba(200,200,200,0.6)";
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.fillText(nm.label || "?", x + 8, y - 8);
              }
              ctx.restore();
            } catch (err) {
              /* ignore debug drawing errors */
            }
          }

          // Draw code matrix grid (10x10) when we have the 6 markers labeled
          (function drawCodeMatrixIfPresent() {
            try {
              // need TL, TM, TR, BL, BM, BR
              const needed = ["TL", "TM", "TR", "BL", "BM", "BR"];
              const labelMap = {};
              for (const nm of normalMarkers) {
                if (nm && nm.label) labelMap[nm.label] = { x: nm.cx, y: nm.cy };
              }
              const hasAll = needed.every((l) => !!labelMap[l]);
              if (!hasAll) return;

              // compute corners: prefer using cornerWeights from template (relative to 6 markers)
              const detectedOrder = ["TL", "TM", "TR", "BL", "BM", "BR"].map(
                (l) => labelMap[l]
              );

              let TL = labelMap["TL"];
              let TR = labelMap["TR"];
              let BL = labelMap["BL"];
              let BR = labelMap["BR"];

              if (
                matrixTemplate &&
                matrixTemplate.cornerWeights &&
                Object.keys(matrixTemplate.cornerWeights).length >= 4
              ) {
                function applyWeights(w) {
                  let x = 0,
                    y = 0;
                  for (let i = 0; i < 6; i++) {
                    const m = detectedOrder[i];
                    if (!m) continue;
                    const wi = w[i] || 0;
                    x += wi * m.x;
                    y += wi * m.y;
                  }
                  return { x, y };
                }
                try {
                  const cw = matrixTemplate.cornerWeights;
                  if (cw.CTL) TL = applyWeights(cw.CTL);
                  if (cw.CTR) TR = applyWeights(cw.CTR);
                  if (cw.CBL) BL = applyWeights(cw.CBL);
                  if (cw.CBR) BR = applyWeights(cw.CBR);
                } catch (err) {
                  console.warn("failed to apply corner weights", err);
                }
              }

              // draw a light polygon showing region
              ctx.save();
              ctx.strokeStyle = "rgba(255,255,0,0.8)";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(TL.x, TL.y);
              ctx.lineTo(TR.x, TR.y);
              ctx.lineTo(BR.x, BR.y);
              ctx.lineTo(BL.x, BL.y);
              ctx.closePath();
              ctx.stroke();

              // bilinear interpolation across the quad for a 10x10 grid
              const rows = 10,
                cols = 10;

              // determine template extents (u/v in [0,1]) if available
              let umin = 0,
                umax = 1,
                vmin = 0,
                vmax = 1;
              if (
                matrixTemplate &&
                matrixTemplate.points &&
                matrixTemplate.points.length > 0
              ) {
                umin = matrixTemplate.umin;
                umax = matrixTemplate.umax;
                vmin = matrixTemplate.vmin;
                vmax = matrixTemplate.vmax;
              }

              // If user supplied only 4 circle percents, draw those 4 points and return
              if (
                typeof circleTemplate !== "undefined" &&
                circleTemplate &&
                circleTemplate.circles
              ) {
                try {
                  // compute the four circle corners in image coordinates
                  const cKeys = ["CTL", "CTR", "CBL", "CBR"];
                  const circlesPos = {};
                  for (const key of cKeys) {
                    const pct = circleTemplate.circles[key];
                    if (!pct) continue;
                    const u = (pct.percent_x || 0) / 100.0;
                    const v = (pct.percent_y || 0) / 100.0;
                    const x =
                      (1 - u) * (1 - v) * TL.x +
                      u * (1 - v) * TR.x +
                      (1 - u) * v * BL.x +
                      u * v * BR.x;
                    const y =
                      (1 - u) * (1 - v) * TL.y +
                      u * (1 - v) * TR.y +
                      (1 - u) * v * BL.y +
                      u * v * BR.y;
                    circlesPos[key] = { x, y };
                  }

                  // only draw the full 10x10 grid inside the area defined by CTL,CTR,CBL,CBR
                  if (
                    circlesPos.CTL &&
                    circlesPos.CTR &&
                    circlesPos.CBL &&
                    circlesPos.CBR
                  ) {
                    const rowsT = 10,
                      colsT = 10;
                    for (let r = 0; r < rowsT; r++) {
                      const v = rowsT === 1 ? 0 : r / (rowsT - 1);
                      for (let c = 0; c < colsT; c++) {
                        const u = colsT === 1 ? 0 : c / (colsT - 1);
                        const x =
                          (1 - u) * (1 - v) * circlesPos.CTL.x +
                          u * (1 - v) * circlesPos.CTR.x +
                          (1 - u) * v * circlesPos.CBL.x +
                          u * v * circlesPos.CBR.x;
                        const y =
                          (1 - u) * (1 - v) * circlesPos.CTL.y +
                          u * (1 - v) * circlesPos.CTR.y +
                          (1 - u) * v * circlesPos.CBL.y +
                          u * v * circlesPos.CBR.y;
                        ctx.beginPath();
                        ctx.fillStyle = "rgba(255,220,0,0.95)";
                        ctx.arc(
                          Math.round(x),
                          Math.round(y),
                          3,
                          0,
                          Math.PI * 2
                        );
                        ctx.fill();
                      }
                    }
                  }

                  // highlight the 4 template circles on top
                  for (const key of Object.keys(circleTemplate.circles)) {
                    const p = circlesPos[key];
                    if (!p) continue;
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(0,255,128,0.95)";
                    ctx.arc(
                      Math.round(p.x),
                      Math.round(p.y),
                      6,
                      0,
                      Math.PI * 2
                    );
                    ctx.fill();
                    ctx.fillStyle = "#000";
                    ctx.font = "14px monospace";
                    ctx.fillText(key, Math.round(p.x) + 8, Math.round(p.y) - 8);
                  }
                } catch (err) {
                  console.warn("failed drawing circleTemplate points", err);
                }
              } else {
                for (let r = 0; r < rows; r++) {
                  const v =
                    rows === 1 ? vmin : vmin + (vmax - vmin) * (r / (rows - 1));
                  for (let c = 0; c < cols; c++) {
                    const u =
                      cols === 1
                        ? umin
                        : umin + (umax - umin) * (c / (cols - 1));
                    // bilinear: P(u,v) = (1-u)(1-v)*TL + u(1-v)*TR + (1-u)v*BL + u v * BR
                    const x =
                      (1 - u) * (1 - v) * TL.x +
                      u * (1 - v) * TR.x +
                      (1 - u) * v * BL.x +
                      u * v * BR.x;
                    const y =
                      (1 - u) * (1 - v) * TL.y +
                      u * (1 - v) * TR.y +
                      (1 - u) * v * BL.y +
                      u * v * BR.y;
                    // draw point
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(255,220,0,0.95)";
                    ctx.arc(Math.round(x), Math.round(y), 3, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
              }
              ctx.restore();
            } catch (err) {
              /* ignore drawing errors */
            }
          })();

          // If all 6 markers detected, capture last frame (with marks) once
          let totalDetected = markerCount;
          if (totalDetected >= 6 && !captured) {
            captured = true;
            // prepare final lists
            let finalNormals = normalMarkers.slice();

            // capture canvas image
            const dataURL = canvas.toDataURL("image/png");

            // determine rotation so the side with 3 markers becomes the top
            // Try 0/90/180/270 and pick the angle where the row with 3
            // markers is in the top half of the rotated image.
            let rot = 0;
            const angles = [0, 90, 180, 270];
            const cx0 = width / 2,
              cy0 = height / 2;
            function rotatePointForAngle(x, y, angle) {
              const a = (angle * Math.PI) / 180;
              const rw = angle % 180 === 0 ? width : height;
              const rh = angle % 180 === 0 ? height : width;
              const newCx = rw / 2,
                newCy = rh / 2;
              const tx = x - cx0,
                ty = y - cy0;
              const rx = tx * Math.cos(a) - ty * Math.sin(a);
              const ry = tx * Math.sin(a) + ty * Math.cos(a);
              return { x: rx + newCx, y: ry + newCy };
            }

            let found = null;
            for (let a of angles) {
              const rw = a % 180 === 0 ? width : height;
              const rh = a % 180 === 0 ? height : width;
              const rotated = finalNormals.map((p) => {
                const rp = rotatePointForAngle(p.cx, p.cy, a);
                return { x: rp.x, y: rp.y };
              });
              const topCount = rotated.filter((p) => p.y < rh / 2).length;
              const bottomCount = rotated.length - topCount;
              if (topCount === 3 && bottomCount === 3) {
                found = a;
                break;
              }
            }
            if (found !== null) rot = found;
            else {
              // fallback: choose rotation minimizing distance to 3/3 partition
              let best = { angle: 0, score: Infinity };
              for (let a of angles) {
                const rw = a % 180 === 0 ? width : height;
                const rh = a % 180 === 0 ? height : width;
                const rotated = finalNormals.map((p) => {
                  const rp = rotatePointForAngle(p.cx, p.cy, a);
                  return { x: rp.x, y: rp.y };
                });
                const topCount = rotated.filter((p) => p.y < rh / 2).length;
                const bottomCount = rotated.length - topCount;
                const score =
                  Math.abs(topCount - 3) + Math.abs(bottomCount - 3);
                if (score < best.score) best = { angle: a, score };
              }
              rot = best.angle;
            }

            // show snapshot overlay
            createSnapshotOverlay(dataURL, rot, finalNormals, width, height);
          }

          // cleanup
          dst.delete();
          contours.delete();
          hierarchy.delete();

          if (!captured) requestAnimationFrame(loop);
        }

        function createSnapshotOverlay(
          dataURL,
          rotationDeg,
          normals,
          srcW,
          srcH
        ) {
          // remove existing overlay if any
          const existing = document.getElementById("omrSnapshotOverlay");
          if (existing) existing.remove();

          const overlay = document.createElement("div");
          overlay.id = "omrSnapshotOverlay";
          overlay.style.position = "fixed";
          overlay.style.left = "0";
          overlay.style.top = "0";
          overlay.style.width = "100%";
          overlay.style.height = "100%";
          overlay.style.display = "flex";
          overlay.style.alignItems = "center";
          overlay.style.justifyContent = "center";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.zIndex = 9999;

          const panel = document.createElement("div");
          panel.style.background = "#222";
          panel.style.padding = "12px";
          panel.style.borderRadius = "8px";
          panel.style.color = "#fff";
          panel.style.maxWidth = "95%";
          panel.style.maxHeight = "95%";
          panel.style.overflow = "auto";

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "Cerrar y continuar";
          closeBtn.style.marginBottom = "8px";
          closeBtn.onclick = () => {
            overlay.remove();
            // resume loop
            captured = false;
            try {
              loop();
            } catch (e) {
              /* ignore */
            }
          };

          const info = document.createElement("div");
          info.style.display = "flex";
          info.style.gap = "12px";

          const canvasWrap = document.createElement("div");
          const snapCanvas = document.createElement("canvas");
          snapCanvas.style.maxWidth = "80vw";
          snapCanvas.style.maxHeight = "80vh";
          canvasWrap.appendChild(snapCanvas);

          const list = document.createElement("div");
          list.style.minWidth = "220px";
          list.style.fontFamily = "monospace";

          const title = document.createElement("div");
          title.textContent = "Snapshot - coordenadas (px)";
          title.style.marginBottom = "8px";
          list.appendChild(title);

          const ul = document.createElement("ul");
          list.appendChild(ul);

          info.appendChild(canvasWrap);
          info.appendChild(list);
          panel.appendChild(closeBtn);
          panel.appendChild(info);
          overlay.appendChild(panel);
          document.body.appendChild(overlay);

          const img = new Image();
          img.onload = () => {
            // prepare canvas size according to rotation
            const angle = ((rotationDeg % 360) + 360) % 360;
            let dw = img.width,
              dh = img.height;
            if (angle === 90 || angle === 270) {
              snapCanvas.width = dh;
              snapCanvas.height = dw;
            } else {
              snapCanvas.width = dw;
              snapCanvas.height = dh;
            }
            const sctx = snapCanvas.getContext("2d");
            // clear
            sctx.fillStyle = "#000";
            sctx.fillRect(0, 0, snapCanvas.width, snapCanvas.height);
            // transform and draw
            sctx.save();
            sctx.translate(snapCanvas.width / 2, snapCanvas.height / 2);
            sctx.rotate((angle * Math.PI) / 180);
            sctx.drawImage(img, -img.width / 2, -img.height / 2);
            sctx.restore();

            // rotate points and draw markers + list
            const cx0 = srcW / 2,
              cy0 = srcH / 2;
            const newCx = snapCanvas.width / 2,
              newCy = snapCanvas.height / 2;
            const angleRad = (angle * Math.PI) / 180;
            function rotatePoint(x, y) {
              const tx = x - cx0;
              const ty = y - cy0;
              const rx = tx * Math.cos(angleRad) - ty * Math.sin(angleRad);
              const ry = tx * Math.sin(angleRad) + ty * Math.cos(angleRad);
              return { x: Math.round(rx + newCx), y: Math.round(ry + newCy) };
            }

            // draw normals and collect label mapping
            const labelMap = {};
            normals.forEach((n, idx) => {
              const rp = rotatePoint(n.cx, n.cy);
              labelMap[n.label] = rp;
              sctx.beginPath();
              sctx.arc(rp.x, rp.y, 6, 0, Math.PI * 2);
              sctx.fillStyle = "cyan";
              sctx.fill();
              sctx.fillStyle = "#fff";
              sctx.font = "14px monospace";
              sctx.fillText(n.label + ` (${rp.x},${rp.y})`, rp.x + 8, rp.y - 8);
              const li = document.createElement("li");
              li.textContent = `${n.label}: ${Math.round(n.cx)}, ${Math.round(
                n.cy
              )}`;
              ul.appendChild(li);
            });

            // No special marker in 6-marker workflow

            // draw connection lines for visualization
            function drawLine(a, b, color) {
              if (a && b) {
                sctx.strokeStyle = color || "#0f0";
                sctx.lineWidth = 2;
                sctx.beginPath();
                sctx.moveTo(a.x, a.y);
                sctx.lineTo(b.x, b.y);
                sctx.stroke();
              }
            }
            drawLine(labelMap["TL"], labelMap["TM"], "#88f");
            drawLine(labelMap["TM"], labelMap["TR"], "#88f");
            drawLine(labelMap["BL"], labelMap["BM"], "#88f");
            drawLine(labelMap["BM"], labelMap["BR"], "#88f");
            drawLine(labelMap["TL"], labelMap["BL"], "#8f8");
            drawLine(labelMap["TM"], labelMap["BM"], "#8f8");
            drawLine(labelMap["TR"], labelMap["BR"], "#8f8");

            // If we have the four corners (TL,TR,BL,BR) perform perspective correction
            const required = ["TL", "TR", "BL", "BR"];
            const hasAll = required.every((l) => !!labelMap[l]);
            if (hasAll && typeof cv !== "undefined") {
              try {
                function dist(a, b) {
                  const dx = a.x - b.x,
                    dy = a.y - b.y;
                  return Math.hypot(dx, dy);
                }
                const topW = dist(labelMap["TL"], labelMap["TR"]);
                const botW = dist(labelMap["BL"], labelMap["BR"]);
                const leftH = dist(labelMap["TL"], labelMap["BL"]);
                const rightH = dist(labelMap["TR"], labelMap["BR"]);
                const dstW = Math.max(1, Math.round((topW + botW) / 2));
                const dstH = Math.max(1, Math.round((leftH + rightH) / 2));

                const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  labelMap["TL"].x,
                  labelMap["TL"].y,
                  labelMap["TR"].x,
                  labelMap["TR"].y,
                  labelMap["BL"].x,
                  labelMap["BL"].y,
                  labelMap["BR"].x,
                  labelMap["BR"].y,
                ]);
                const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  0,
                  0,
                  dstW,
                  0,
                  0,
                  dstH,
                  dstW,
                  dstH,
                ]);

                let srcMat = cv.imread(snapCanvas);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                let dstMat = new cv.Mat();
                let dsize = new cv.Size(dstW, dstH);
                cv.warpPerspective(
                  srcMat,
                  dstMat,
                  M,
                  dsize,
                  cv.INTER_LINEAR,
                  cv.BORDER_CONSTANT,
                  new cv.Scalar()
                );

                const corrected = document.createElement("canvas");
                corrected.width = dstW;
                corrected.height = dstH;
                corrected.style.maxWidth = "80vw";
                corrected.style.display = "block";
                const corrWrap = document.createElement("div");
                corrWrap.style.marginTop = "8px";
                corrWrap.appendChild(corrected);
                canvasWrap.appendChild(corrWrap);
                cv.imshow(corrected, dstMat);

                // draw small marker at corners for visual check
                const cctx = corrected.getContext("2d");
                cctx.fillStyle = "red";
                cctx.beginPath();
                cctx.arc(6, 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(dstW - 6, 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(6, dstH - 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(dstW - 6, dstH - 6, 6, 0, Math.PI * 2);
                cctx.fill();

                // cleanup
                srcTri.delete();
                dstTri.delete();
                srcMat.delete();
                M.delete();
                dstMat.delete();
              } catch (err) {
                console.error("Persp transform failed", err);
              }
            }
          };
          img.src = dataURL;
        }

        loop();
      }
    </script>
  </body>
</html>
