<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Detector OMR en Tiempo Real</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f5f5f5;
        overflow-x: hidden;
      }
      .container {
        margin: 0 auto;
        padding: 10px;
      }
      .video-and-controls-wrapper {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }
      .video-container {
        max-width: 400px;
        max-height: 300px;
        margin: 0;
        background: #000;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #ccc;
      }
      #video {
        display: none;
      }
      #canvasOutput {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
      }
      canvas {
        display: block;
      }
      .contrast-slider-container {
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        margin-top: 20px;
      }
      .contrast-slider-container label {
        white-space: nowrap;
        margin-top: 10px;
      }
      .contrast-slider-container input[type="range"] {
        width: 200px;
        height: 20px;
        -webkit-appearance: none;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 5px;
      }
      .contrast-slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
      .contrast-slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ“¹ Detector OMR - Vista Binaria</h1>
      <div id="status">Cargando OpenCV.js...</div>

      <div class="controls">
        <button id="stopBtn" class="stop" disabled style="display: none">
          Detener
        </button>
        <button id="retryBtn" disabled style="display: none">Reintentar</button>
      </div>

      <div class="video-and-controls-wrapper">
        <div class="video-container">
          <video
            id="video"
            autoplay
            playsinline
            width="640"
            height="480"
            style="display: none"
          ></video>
          <canvas id="canvasOutput" width="640" height="480"></canvas>
        </div>

        <div class="contrast-slider-container">
          <label
            >Contraste:
            <input id="contrast" type="range" min="0" max="200" value="100"
          /></label>
        </div>
      </div>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.5.2/opencv.js"
      onload="onOpenCvReady()"
    ></script>

    <script>
      function onOpenCvReady() {
        startCamera();
      }

      function startCamera() {
        const video = document.getElementById("video");
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
              video.play();
              initOpenCV();
            };
          })
          .catch((err) => console.error(err));
      }

      function initOpenCV() {
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvasOutput");
        const ctx = canvas.getContext("2d");

        const width = video.videoWidth;
        const height = video.videoHeight;
        canvas.width = width;
        canvas.height = height;

        let src = new cv.Mat(height, width, cv.CV_8UC4);
        let gray = new cv.Mat(height, width, cv.CV_8UC1);
        let bw = new cv.Mat(height, width, cv.CV_8UC1);

        const contrastInput = document.getElementById("contrast");
        let contrastValue = parseFloat(contrastInput.value) / 100.0;
        contrastInput.oninput = () => {
          contrastValue = parseFloat(contrastInput.value) / 100.0;
        };
        contrastInput.addEventListener(
          "touchmove",
          (e) => {
            e.stopPropagation();
            e.preventDefault();
          },
          { passive: false }
        );

        let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
        let captured = false;

        function loop() {
          ctx.drawImage(video, 0, 0, width, height);
          let imageData = ctx.getImageData(0, 0, width, height);
          src.data.set(imageData.data);

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.convertScaleAbs(gray, gray, contrastValue, 0);
          cv.GaussianBlur(gray, gray, new cv.Size(3, 3), 0);
          clahe.apply(gray, gray);
          cv.threshold(gray, bw, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          // Detect contours
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(
            bw,
            contours,
            hierarchy,
            cv.RETR_TREE,
            cv.CHAIN_APPROX_SIMPLE
          );

          let dst = new cv.Mat();
          cv.cvtColor(bw, dst, cv.COLOR_GRAY2RGBA);

          // Detect normal markers (outer rect with inner rect), compute centroids and label regions
          let markerCount = 0;
          let innerAreas = [];
          let normalMarkers = []; // {outerIdx, innerIdx, innerArea, cx, cy, label}
          let hierArr = null;
          try {
            hierArr = hierarchy.data32S;
          } catch (e) {
            hierArr = null;
          }

          const minArea = Math.max(100, width * height * 0.0005);
          const labelsGrid = [
            ["TL", "TM", "TR"],
            ["BL", "BM", "BRE"],
          ];

          for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < minArea) continue;
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            if (approx.rows === 4 && cv.isContourConvex(approx)) {
              let childIdx = -1;
              if (hierArr) childIdx = hierArr[i * 4 + 2];
              if (childIdx !== -1) {
                let childCnt = contours.get(childIdx);
                let childArea = cv.contourArea(childCnt);
                if (
                  childArea > 0 &&
                  childArea / area > 0.01 &&
                  childArea / area < 0.9
                ) {
                  let cPeri = cv.arcLength(childCnt, true);
                  let cApprox = new cv.Mat();
                  cv.approxPolyDP(childCnt, cApprox, 0.02 * cPeri, true);
                  if (cApprox.rows === 4 && cv.isContourConvex(cApprox)) {
                    // centroid of inner contour
                    let m = cv.moments(childCnt);
                    let cx = 0,
                      cy = 0;
                    if (m.m00 && m.m00 !== 0) {
                      cx = m.m10 / m.m00;
                      cy = m.m01 / m.m00;
                    } else {
                      let r = cv.boundingRect(childCnt);
                      cx = r.x + r.width / 2;
                      cy = r.y + r.height / 2;
                    }

                    // map to grid label
                    let col = Math.min(
                      2,
                      Math.max(0, Math.floor(cx / (width / 3)))
                    );
                    let row = Math.min(
                      1,
                      Math.max(0, Math.floor(cy / (height / 2)))
                    );
                    let regionLabel = labelsGrid[row][col];

                    markerCount++;
                    innerAreas.push(childArea);
                    normalMarkers.push({
                      outerIdx: i,
                      innerIdx: childIdx,
                      innerArea: childArea,
                      cx: cx,
                      cy: cy,
                      label: regionLabel,
                    });

                    cv.drawContours(
                      dst,
                      contours,
                      i,
                      new cv.Scalar(0, 255, 0, 255),
                      2,
                      cv.LINE_8,
                      hierarchy,
                      0
                    );
                    cv.drawContours(
                      dst,
                      contours,
                      childIdx,
                      new cv.Scalar(0, 128, 255, 255),
                      2,
                      cv.LINE_8
                    );
                    cv.putText(
                      dst,
                      regionLabel,
                      new cv.Point(Math.round(cx) - 12, Math.round(cy) - 12),
                      cv.FONT_HERSHEY_SIMPLEX,
                      0.7,
                      new cv.Scalar(255, 255, 255, 255),
                      2
                    );
                  }
                  cApprox.delete();
                }
              }
            }
            approx.delete();
          }

          // Average inner area (use median to be robust)
          let avgInnerArea = 0;
          let medianInnerArea = 0;
          if (innerAreas.length > 0) {
            avgInnerArea =
              innerAreas.reduce((a, b) => a + b, 0) / innerAreas.length;
            // median
            let sorted = innerAreas.slice().sort((a, b) => a - b);
            let mid = Math.floor(sorted.length / 2);
            medianInnerArea =
              sorted.length % 2 !== 0
                ? sorted[mid]
                : (sorted[mid - 1] + sorted[mid]) / 2;
          }

          // Expect special inner area when linear size is 20% (80% smaller)
          // area factor ~0.20^2 = 0.04
          const specialAreaFactor = 0.04;
          let expectedSpecialArea =
            medianInnerArea > 0 ? medianInnerArea * specialAreaFactor : 0;

          // First try: find among normalMarkers any with innerArea close to expectedSpecialArea
          let specialCount = 0;
          let specialsDetected = [];
          // store special marker info when found
          let specialMarker = null;
          if (expectedSpecialArea > 0) {
            // widen tolerance for very small markers to avoid missing them
            const lowerS = expectedSpecialArea * 0.4;
            const upperS = expectedSpecialArea * 2.0;
            for (let k = 0; k < normalMarkers.length; ++k) {
              let nm = normalMarkers[k];
              if (nm.innerArea >= lowerS && nm.innerArea <= upperS) {
                specialCount++;
                specialsDetected.push({
                  type: "normalInner",
                  idx: k,
                  area: nm.innerArea,
                });
                specialMarker = {
                  cx: nm.cx,
                  cy: nm.cy,
                  label: nm.label,
                  from: "normal",
                };
                // draw special around outer in red
                cv.drawContours(
                  dst,
                  contours,
                  nm.outerIdx,
                  new cv.Scalar(255, 0, 0, 255),
                  3,
                  cv.LINE_8,
                  hierarchy,
                  0
                );
                cv.putText(
                  dst,
                  nm.label + "*",
                  new cv.Point(Math.round(nm.cx) - 16, Math.round(nm.cy) - 16),
                  cv.FONT_HERSHEY_SIMPLEX,
                  0.7,
                  new cv.Scalar(255, 255, 255, 255),
                  2
                );
                // reduce markerCount (we'll treat this as special)
                markerCount = Math.max(0, markerCount - 1);
              }
            }
          }

          // Second try: if none found, attempt inverted-image detection (legacy)
          if (specialCount === 0 && avgInnerArea > 0) {
            let bwInv = new cv.Mat();
            cv.bitwise_not(bw, bwInv);
            let contoursInv = new cv.MatVector();
            let hierInv = new cv.Mat();
            cv.findContours(
              bwInv,
              contoursInv,
              hierInv,
              cv.RETR_EXTERNAL,
              cv.CHAIN_APPROX_SIMPLE
            );

            const lower = avgInnerArea * 0.5;
            const upper = avgInnerArea * 1.6;
            for (let j = 0; j < contoursInv.size(); ++j) {
              let cnt = contoursInv.get(j);
              let area = cv.contourArea(cnt);
              if (area < 10) continue;
              if (area >= lower && area <= upper) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                if (approx.rows === 4 && cv.isContourConvex(approx)) {
                  // compute centroid of inverted contour
                  let mInv = cv.moments(cnt);
                  let scx = 0,
                    scy = 0;
                  if (mInv.m00 && mInv.m00 !== 0) {
                    scx = mInv.m10 / mInv.m00;
                    scy = mInv.m01 / mInv.m00;
                  } else {
                    let rInv = cv.boundingRect(cnt);
                    scx = rInv.x + rInv.width / 2;
                    scy = rInv.y + rInv.height / 2;
                  }
                  specialCount++;
                  specialsDetected.push({
                    contourIdx: j,
                    area: area,
                    cx: scx,
                    cy: scy,
                  });
                  specialMarker = {
                    cx: scx,
                    cy: scy,
                    label: null,
                    from: "inverted",
                  };
                  cv.drawContours(
                    dst,
                    contoursInv,
                    j,
                    new cv.Scalar(255, 0, 0, 255),
                    2,
                    cv.LINE_8
                  );
                }
                approx.delete();
              }
            }

            bwInv.delete();
            contoursInv.delete();
            hierInv.delete();
          }

          // If still no special detected by area, promote normal marker in BRE to special (if present)
          if (specialCount === 0) {
            let bre = normalMarkers.find((n) => n.label === "BRE");
            if (bre) {
              specialCount = 1;
              markerCount = Math.max(0, markerCount - 1);
              cv.drawContours(
                dst,
                contours,
                bre.outerIdx,
                new cv.Scalar(255, 0, 0, 255),
                3,
                cv.LINE_8,
                hierarchy,
                0
              );
              cv.putText(
                dst,
                "BRE*",
                new cv.Point(Math.round(bre.cx) - 16, Math.round(bre.cy) - 16),
                cv.FONT_HERSHEY_SIMPLEX,
                0.7,
                new cv.Scalar(255, 255, 255, 255),
                2
              );
            }
          }

          cv.putText(
            dst,
            "Normales: " + markerCount,
            new cv.Point(10, 30),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 255, 0, 255),
            2
          );
          cv.putText(
            dst,
            "Especiales: " + specialCount,
            new cv.Point(10, 60),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 0, 255, 255),
            2
          );

          cv.imshow("canvasOutput", dst);

          // If all 6 markers detected, capture last frame (with marks) once
          let totalDetected = markerCount + specialCount;
          if (totalDetected >= 6 && !captured) {
            captured = true;
            // prepare final lists
            let finalNormals = normalMarkers.slice();
            let special = null;
            // if specialMarker set, use it
            if (specialMarker) {
              special = specialMarker;
              if (special.from === "normal") {
                // remove the normal that became special
                let entry = specialsDetected.find(
                  (s) => s.type === "normalInner"
                );
                if (entry && typeof entry.idx === "number") {
                  finalNormals.splice(entry.idx, 1);
                }
              }
            } else if (
              specialsDetected.length > 0 &&
              specialsDetected[0].cx !== undefined
            ) {
              special = {
                cx: specialsDetected[0].cx,
                cy: specialsDetected[0].cy,
                label: null,
                from: "inverted",
              };
            } else {
              // fallback: promote BRE
              let bre = normalMarkers.find((n) => n.label === "BRE");
              if (bre) {
                special = {
                  cx: bre.cx,
                  cy: bre.cy,
                  label: "BRE",
                  from: "promoted",
                };
                // remove bre from normals
                finalNormals = finalNormals.filter(
                  (n) => !(n.cx === bre.cx && n.cy === bre.cy)
                );
              }
            }

            // capture canvas image
            const dataURL = canvas.toDataURL("image/png");

            // determine rotation so special moves to BRE (bottom-right)
            let rot = 0;
            if (special) {
              let dx = special.cx - width / 2;
              let dy = special.cy - height / 2;
              if (dx > 0 && dy > 0) rot = 0;
              else if (dx < 0 && dy > 0) rot = 90;
              else if (dx < 0 && dy < 0) rot = 180;
              else if (dx > 0 && dy < 0) rot = 270;
            }

            // show snapshot overlay
            createSnapshotOverlay(
              dataURL,
              rot,
              finalNormals,
              special,
              width,
              height
            );
          }

          // cleanup
          dst.delete();
          contours.delete();
          hierarchy.delete();

          if (!captured) requestAnimationFrame(loop);
        }

        function createSnapshotOverlay(
          dataURL,
          rotationDeg,
          normals,
          special,
          srcW,
          srcH
        ) {
          // remove existing overlay if any
          const existing = document.getElementById("omrSnapshotOverlay");
          if (existing) existing.remove();

          const overlay = document.createElement("div");
          overlay.id = "omrSnapshotOverlay";
          overlay.style.position = "fixed";
          overlay.style.left = "0";
          overlay.style.top = "0";
          overlay.style.width = "100%";
          overlay.style.height = "100%";
          overlay.style.display = "flex";
          overlay.style.alignItems = "center";
          overlay.style.justifyContent = "center";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.zIndex = 9999;

          const panel = document.createElement("div");
          panel.style.background = "#222";
          panel.style.padding = "12px";
          panel.style.borderRadius = "8px";
          panel.style.color = "#fff";
          panel.style.maxWidth = "95%";
          panel.style.maxHeight = "95%";
          panel.style.overflow = "auto";

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "Cerrar y continuar";
          closeBtn.style.marginBottom = "8px";
          closeBtn.onclick = () => {
            overlay.remove();
            // resume loop
            captured = false;
            try {
              loop();
            } catch (e) {
              /* ignore */
            }
          };

          const info = document.createElement("div");
          info.style.display = "flex";
          info.style.gap = "12px";

          const canvasWrap = document.createElement("div");
          const snapCanvas = document.createElement("canvas");
          snapCanvas.style.maxWidth = "80vw";
          snapCanvas.style.maxHeight = "80vh";
          canvasWrap.appendChild(snapCanvas);

          const list = document.createElement("div");
          list.style.minWidth = "220px";
          list.style.fontFamily = "monospace";

          const title = document.createElement("div");
          title.textContent = "Snapshot - coordenadas (px)";
          title.style.marginBottom = "8px";
          list.appendChild(title);

          const ul = document.createElement("ul");
          list.appendChild(ul);

          info.appendChild(canvasWrap);
          info.appendChild(list);
          panel.appendChild(closeBtn);
          panel.appendChild(info);
          overlay.appendChild(panel);
          document.body.appendChild(overlay);

          const img = new Image();
          img.onload = () => {
            // prepare canvas size according to rotation
            const angle = ((rotationDeg % 360) + 360) % 360;
            let dw = img.width,
              dh = img.height;
            if (angle === 90 || angle === 270) {
              snapCanvas.width = dh;
              snapCanvas.height = dw;
            } else {
              snapCanvas.width = dw;
              snapCanvas.height = dh;
            }
            const sctx = snapCanvas.getContext("2d");
            // clear
            sctx.fillStyle = "#000";
            sctx.fillRect(0, 0, snapCanvas.width, snapCanvas.height);
            // transform and draw
            sctx.save();
            sctx.translate(snapCanvas.width / 2, snapCanvas.height / 2);
            sctx.rotate((angle * Math.PI) / 180);
            sctx.drawImage(img, -img.width / 2, -img.height / 2);
            sctx.restore();

            // rotate points and draw markers + list
            const cx0 = srcW / 2,
              cy0 = srcH / 2;
            const newCx = snapCanvas.width / 2,
              newCy = snapCanvas.height / 2;
            const angleRad = (angle * Math.PI) / 180;
            function rotatePoint(x, y) {
              const tx = x - cx0;
              const ty = y - cy0;
              const rx = tx * Math.cos(angleRad) - ty * Math.sin(angleRad);
              const ry = tx * Math.sin(angleRad) + ty * Math.cos(angleRad);
              return { x: Math.round(rx + newCx), y: Math.round(ry + newCy) };
            }

            // draw normals
            normals.forEach((n, idx) => {
              const rp = rotatePoint(n.cx, n.cy);
              sctx.beginPath();
              sctx.arc(rp.x, rp.y, 6, 0, Math.PI * 2);
              sctx.fillStyle = "cyan";
              sctx.fill();
              sctx.fillStyle = "#fff";
              sctx.font = "14px monospace";
              sctx.fillText(n.label + ` (${rp.x},${rp.y})`, rp.x + 8, rp.y - 8);
              const li = document.createElement("li");
              li.textContent = `${n.label}: ${Math.round(n.cx)}, ${Math.round(
                n.cy
              )}`;
              ul.appendChild(li);
            });

            if (special) {
              const rp = rotatePoint(special.cx, special.cy);
              sctx.beginPath();
              sctx.arc(rp.x, rp.y, 8, 0, Math.PI * 2);
              sctx.fillStyle = "red";
              sctx.fill();
              sctx.fillStyle = "#fff";
              sctx.font = "16px monospace";
              sctx.fillText("SPECIAL", rp.x + 10, rp.y + 6);
              const li = document.createElement("li");
              li.textContent = `SPECIAL (${
                special.label || "unknown"
              }): ${Math.round(special.cx)}, ${Math.round(special.cy)}`;
              ul.appendChild(li);
            }
          };
          img.src = dataURL;
        }

        loop();
      }
    </script>
  </body>
</html>
