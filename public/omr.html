<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Detector OMR en Tiempo Real</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f5f5f5;
        overflow-x: hidden;
      }
      .container {
        margin: 0 auto;
        padding: 10px;
      }
      .video-and-controls-wrapper {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }
      .video-container {
        max-width: 400px;
        max-height: 300px;
        margin: 0;
        background: #000;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #ccc;
      }
      #video {
        display: none;
      }
      #canvasOutput {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
      }
      canvas {
        display: block;
      }
      .contrast-slider-container {
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        margin-top: 20px;
      }
      .contrast-slider-container label {
        white-space: nowrap;
        margin-top: 10px;
      }
      .contrast-slider-container input[type="range"] {
        width: 200px;
        height: 20px;
        -webkit-appearance: none;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 5px;
      }
      .contrast-slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
      .contrast-slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ“¹ Detector OMR - Vista Binaria</h1>
      <div id="status">Cargando OpenCV.js...</div>

      <div class="controls">
        <button id="stopBtn" class="stop" disabled style="display: none">
          Detener
        </button>
        <button id="retryBtn" disabled style="display: none">Reintentar</button>
      </div>

      <div class="video-and-controls-wrapper">
        <div class="video-container">
          <video
            id="video"
            autoplay
            playsinline
            width="640"
            height="480"
            style="display: none"
          ></video>
          <canvas id="canvasOutput" width="640" height="480"></canvas>
        </div>

        <div class="contrast-slider-container">
          <label
            >Contraste:
            <input id="contrast" type="range" min="0" max="200" value="100"
          /></label>
        </div>
      </div>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.5.2/opencv.js"
      onload="onOpenCvReady()"
    ></script>

    <script>
      function onOpenCvReady() {
        startCamera();
      }

      function startCamera() {
        const video = document.getElementById("video");
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
              video.play();
              initOpenCV();
            };
          })
          .catch((err) => console.error(err));
      }

      function initOpenCV() {
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvasOutput");
        const ctx = canvas.getContext("2d");

        const width = video.videoWidth;
        const height = video.videoHeight;
        canvas.width = width;
        canvas.height = height;

        // offscreen clean canvas to store a frame without overlays
        let cleanCanvas = document.createElement("canvas");
        cleanCanvas.width = width;
        cleanCanvas.height = height;
        let cleanCtx = cleanCanvas.getContext("2d");
        // last clean frame dataURL (updated each frame before any overlays are drawn)
        let lastCleanDataURL = null;
        // offscreen processed canvas (alto contraste / binaria) without overlays
        let procCanvas = document.createElement("canvas");
        procCanvas.width = width;
        procCanvas.height = height;
        let lastProcessedDataURL = null;

        let src = new cv.Mat(height, width, cv.CV_8UC4);
        let gray = new cv.Mat(height, width, cv.CV_8UC1);
        let bw = new cv.Mat(height, width, cv.CV_8UC1);

        const contrastInput = document.getElementById("contrast");
        // restore last contrast value from previous session if present
        try {
          const stored = localStorage.getItem("omrContrast");
          if (stored !== null) contrastInput.value = stored;
        } catch (e) {
          /* ignore localStorage errors */
        }
        let contrastValue = parseFloat(contrastInput.value) / 100.0;
        contrastInput.oninput = () => {
          contrastValue = parseFloat(contrastInput.value) / 100.0;
          try {
            localStorage.setItem("omrContrast", contrastInput.value);
          } catch (e) {
            /* ignore localStorage errors */
          }
        };
        contrastInput.addEventListener(
          "touchmove",
          (e) => {
            e.stopPropagation();
            e.preventDefault();
          },
          { passive: false }
        );

        let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
        let captured = false;
        let matrixTemplate = null;
        // user-supplied circle template (percentages relative to template rectangle)
        // values provided: percent_x and percent_y (0-100)
        let circleTemplate = {
          rectangle: {
            top_left: { x: 5.597393, y: 5.0 },
            top_right: { x: 114.357054, y: 5.0 },
            bottom_left: { x: 5.597393, y: 74.089405 },
            bottom_right: { x: 114.357054, y: 74.089401 },
            width: 108.759661,
            height: 69.089401,
          },
          circles: {
            CTL: { percent_x: 8.05, percent_y: 7.9 },
            CTR: { percent_x: 30.2, percent_y: 7.9 },
            CBL: { percent_x: 8.05, percent_y: 43 },
            CBR: { percent_x: 30.2, percent_y: 43 },
          },
          // additional matrices (M1Questions..M4Questions) can be defined here
          M1Questions: {
            rectangle: {
              top_left: { x: 5.597393, y: 5.0 },
              top_right: { x: 114.357054, y: 5.0 },
              bottom_left: { x: 5.597393, y: 74.089405 },
              bottom_right: { x: 114.357054, y: 74.089405 },
              width: 108.759661,
              height: 69.089401,
            },
            circles: {
              CTL: { percent_x: 4.3, percent_y: 52.77 },
              CTR: { percent_x: 22, percent_y: 52.77 },
              CBL: { percent_x: 4.3, percent_y: 89.87 },
              CBR: { percent_x: 22, percent_y: 89.87 },
            },
            rows: 10,
            cols: 8,
          },
          M2Questions: {
            rectangle: {
              top_left: { x: 5.597393, y: 5.0 },
              top_right: { x: 114.357054, y: 5.0 },
              bottom_left: { x: 5.597393, y: 74.089405 },
              bottom_right: { x: 114.357054, y: 74.089405 },
              width: 108.759661,
              height: 69.089401,
            },
            circles: {
              CTL: { percent_x: 27.73, percent_y: 52.77 },
              CTR: { percent_x: 47.05, percent_y: 52.77 },
              CBL: { percent_x: 27.73, percent_y: 89.87 },
              CBR: { percent_x: 47.05, percent_y: 89.87 },
            },
          },
          M3Questions: {
            rectangle: {
              top_left: { x: 5.597393, y: 5.0 },
              top_right: { x: 114.357054, y: 5.0 },
              bottom_left: { x: 5.597393, y: 74.089405 },
              bottom_right: { x: 114.357054, y: 74.089405 },
              width: 108.759661,
              height: 69.089401,
            },
            circles: {
              CTL: { percent_x: 51.2, percent_y: 52.77 },
              CTR: { percent_x: 71.1, percent_y: 52.77 },
              CBL: { percent_x: 51.2, percent_y: 89.87 },
              CBR: { percent_x: 71.1, percent_y: 89.87 },
            },
          },
          M4Questions: {
            rectangle: {
              top_left: { x: 5.597393, y: 5.0 },
              top_right: { x: 114.357054, y: 5.0 },
              bottom_left: { x: 5.597393, y: 74.089405 },
              bottom_right: { x: 114.357054, y: 74.089405 },
              width: 108.759661,
              height: 69.089401,
            },
            circles: {
              CTL: { percent_x: 76.59, percent_y: 52.77 },
              CTR: { percent_x: 95.7, percent_y: 52.77 },
              CBL: { percent_x: 76.59, percent_y: 89.87 },
              CBR: { percent_x: 95.7, percent_y: 89.87 },
            },
          },
        };
        // try to fetch the SVG template with matrix definition (matrizCode.txt)
        fetch("matrizCode.txt")
          .then((r) => r.text())
          .then((txt) => {
            try {
              // parse viewBox if present
              let vbMatch = txt.match(
                /viewBox\s*=\s*"([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)\s+([\d.\-]+)"/i
              );
              let vw = 1,
                vh = 1;
              if (vbMatch) {
                vw = parseFloat(vbMatch[3]);
                vh = parseFloat(vbMatch[4]);
              } else {
                // fallback: try width/height
                let wMatch = txt.match(/width\s*=\s*"([\d.]+)mm"/i);
                let hMatch = txt.match(/height\s*=\s*"([\d.]+)mm"/i);
                if (wMatch && hMatch) {
                  vw = parseFloat(wMatch[1]);
                  vh = parseFloat(hMatch[1]);
                }
              }

              const points = [];
              const ellRe =
                /<ellipse[^>]*cx\s*=\s*"([\d.\-]+)"[^>]*cy\s*=\s*"([\d.\-]+)"/gi;
              let m;
              while ((m = ellRe.exec(txt))) {
                const cx = parseFloat(m[1]);
                const cy = parseFloat(m[2]);
                points.push({ u: cx / vw, v: cy / vh, cx, cy });
              }

              // parse marker groups: transform="translate(x,y)" plus inner rects
              const groupRe =
                /<g[^>]*transform\s*=\s*"translate\(([\d.\-]+)\s*,\s*([\d.\-]+)\)"[^>]*>([\s\S]*?)<\/g>/gi;
              const rectRe =
                /<rect[^>]*x\s*=\s*"([\d.\-]+)"[^>]*y\s*=\s*"([\d.\-]+)"[^>]*width\s*=\s*"([\d.\-]+)"[^>]*height\s*=\s*"([\d.\-]+)"/i;
              const markerGroups = [];
              while ((m = groupRe.exec(txt))) {
                const gx = parseFloat(m[1]);
                const gy = parseFloat(m[2]);
                const inner = m[3];
                const r = rectRe.exec(inner);
                if (r) {
                  const rx = parseFloat(r[1]);
                  const ry = parseFloat(r[2]);
                  const rw = parseFloat(r[3]);
                  const rh = parseFloat(r[4]);
                  const cx = gx + rx + rw / 2;
                  const cy = gy + ry + rh / 2;
                  markerGroups.push({ cx, cy, gx, gy });
                }
              }

              let templateMarkers = null;
              if (markerGroups.length >= 6) {
                const sortedByY = markerGroups
                  .slice()
                  .sort((a, b) => a.cy - b.cy);
                const topCandidates = sortedByY
                  .slice(0, 3)
                  .sort((a, b) => a.cx - b.cx);
                const bottomCandidates = sortedByY
                  .slice(-3)
                  .sort((a, b) => a.cx - b.cx);
                templateMarkers = [
                  topCandidates[0],
                  topCandidates[1],
                  topCandidates[2],
                  bottomCandidates[0],
                  bottomCandidates[1],
                  bottomCandidates[2],
                ];
              }

              if (points.length > 0) {
                let umin = Math.min(...points.map((p) => p.u));
                let umax = Math.max(...points.map((p) => p.u));
                let vmin = Math.min(...points.map((p) => p.v));
                let vmax = Math.max(...points.map((p) => p.v));
                matrixTemplate = {
                  vw,
                  vh,
                  points,
                  umin,
                  umax,
                  vmin,
                  vmax,
                  templateMarkers,
                };
                console.log("matrixTemplate loaded: ", matrixTemplate);

                if (templateMarkers && templateMarkers.length === 6) {
                  // compute corner weights for CTL,CTR,CBL,CBR relative to the 6 template markers
                  function computeWeightsForPoint(px, py, markers) {
                    const m6 = markers[5];
                    const B = Array.from({ length: 5 }, () => [0, 0]);
                    for (let i = 0; i < 5; i++) {
                      B[i][0] = markers[i].cx - m6.cx;
                      B[i][1] = markers[i].cy - m6.cy;
                    }
                    const y = [px - m6.cx, py - m6.cy];
                    const BtB = Array.from({ length: 5 }, () =>
                      Array(5).fill(0)
                    );
                    const BtY = Array(5).fill(0);
                    for (let i = 0; i < 5; i++) {
                      for (let j = 0; j < 5; j++) {
                        BtB[i][j] += B[i][0] * B[j][0] + B[i][1] * B[j][1];
                      }
                      BtY[i] += B[i][0] * y[0] + B[i][1] * y[1];
                    }
                    const N = 5;
                    const A = Array.from({ length: N }, (_, r) =>
                      BtB[r].slice()
                    );
                    for (let r = 0; r < N; r++) A[r].push(BtY[r]);
                    for (let i = 0; i < N; i++) {
                      let maxRow = i;
                      for (let k = i + 1; k < N; k++) {
                        if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i]))
                          maxRow = k;
                      }
                      if (Math.abs(A[maxRow][i]) < 1e-9) continue;
                      const tmp = A[i];
                      A[i] = A[maxRow];
                      A[maxRow] = tmp;
                      const diag = A[i][i];
                      for (let j = i; j <= N; j++) A[i][j] /= diag;
                      for (let r = 0; r < N; r++) {
                        if (r === i) continue;
                        const factor = A[r][i];
                        if (Math.abs(factor) < 1e-12) continue;
                        for (let c = i; c <= N; c++)
                          A[r][c] -= factor * A[i][c];
                      }
                    }
                    const w5 = Array(N).fill(0);
                    for (let i = 0; i < N; i++) w5[i] = A[i][N];
                    const w = [];
                    let sum5 = 0;
                    for (let i = 0; i < 5; i++) {
                      w.push(w5[i]);
                      sum5 += w5[i];
                    }
                    w.push(1 - sum5);
                    return w;
                  }

                  const corners = {
                    CTL: null,
                    CTR: null,
                    CBL: null,
                    CBR: null,
                  };
                  if (points.length >= 4) {
                    const midU =
                      (Math.min(...points.map((p) => p.u)) +
                        Math.max(...points.map((p) => p.u))) /
                      2;
                    const left = points
                      .filter((p) => p.u <= midU)
                      .sort((a, b) => a.v - b.v);
                    const right = points
                      .filter((p) => p.u > midU)
                      .sort((a, b) => a.v - b.v);
                    if (left.length >= 2 && right.length >= 2) {
                      corners.CTL = left[0];
                      corners.CBL = left[left.length - 1];
                      corners.CTR = right[0];
                      corners.CBR = right[right.length - 1];
                    } else {
                      const minU = points.reduce((a, b) => (a.u < b.u ? a : b));
                      const maxU = points.reduce((a, b) => (a.u > b.u ? a : b));
                      const minV = points.reduce((a, b) => (a.v < b.v ? a : b));
                      const maxV = points.reduce((a, b) => (a.v > b.v ? a : b));
                      corners.CTL = minU;
                      corners.CBR = maxU;
                      corners.CBL = maxV;
                      corners.CTR = minV;
                    }
                  }

                  const cornerWeights = {};
                  try {
                    const markerCoords = templateMarkers.map((m) => ({
                      cx: m.cx,
                      cy: m.cy,
                    }));
                    for (const key of ["CTL", "CTR", "CBL", "CBR"]) {
                      const cp = corners[key];
                      if (cp) {
                        const px = cp.u * vw;
                        const py = cp.v * vh;
                        cornerWeights[key] = computeWeightsForPoint(
                          px,
                          py,
                          markerCoords
                        );
                      }
                    }
                    matrixTemplate.cornerWeights = cornerWeights;
                    console.log("computed corner weights", cornerWeights);
                  } catch (err) {
                    console.warn("corner weight computation failed", err);
                  }
                }
              }
            } catch (err) {
              console.warn("Failed to parse matrizCode.txt", err);
            }
          })
          .catch(() => {
            /* ignore missing template */
          });
        

        function loop() {
          // draw raw video to visible canvas context first
          ctx.drawImage(video, 0, 0, width, height);
          // update clean offscreen canvas BEFORE any processing/drawing of overlays
          try {
            cleanCtx.drawImage(video, 0, 0, width, height);
            lastCleanDataURL = cleanCanvas.toDataURL("image/png");
          } catch (err) {
            // if something fails, leave lastCleanDataURL as it was
          }

          let imageData = ctx.getImageData(0, 0, width, height);
          src.data.set(imageData.data);

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.convertScaleAbs(gray, gray, contrastValue, 0);
          cv.GaussianBlur(gray, gray, new cv.Size(3, 3), 0);
          clahe.apply(gray, gray);
          cv.threshold(gray, bw, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          // Detect contours
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(
            bw,
            contours,
            hierarchy,
            cv.RETR_TREE,
            cv.CHAIN_APPROX_SIMPLE
          );

          let dst = new cv.Mat();
          cv.cvtColor(bw, dst, cv.COLOR_GRAY2RGBA);
          // render processed (high-contrast / binary -> RGBA) image to offscreen canvas
          try {
            cv.imshow(procCanvas, dst);
            try {
              lastProcessedDataURL = procCanvas.toDataURL("image/png");
            } catch (e) {
              // toDataURL may fail in some environments; ignore
            }
          } catch (e) {
            // if cv.imshow fails for offscreen canvas, ignore and continue
          }

          // Detect normal markers (outer rect with inner rect), compute centroids and label regions
          let markerCount = 0;
          let innerAreas = [];
          let normalMarkers = []; // {outerIdx, innerIdx, innerArea, cx, cy, label}
          let hierArr = null;
          try {
            hierArr = hierarchy.data32S;
          } catch (e) {
            hierArr = null;
          }

          const minArea = Math.max(100, width * height * 0.0005);

          // Expected layout now: top row has 3 markers (TL, TM, TR)
          // bottom row has 3 markers (BL, BM, BR). We'll assign each detected
          // centroid to the nearest expected position to produce labels.
          const topLabels = ["TL", "TM", "TR"];
          const bottomLabels = ["BL", "BM", "BR"];
          const expectedPositions = [];
          for (let i = 0; i < 3; i++)
            expectedPositions.push({
              label: topLabels[i],
              x: ((i + 0.5) * width) / 3,
              y: height * 0.25,
            });
          for (let i = 0; i < 3; i++)
            expectedPositions.push({
              label: bottomLabels[i],
              x: ((i + 0.5) * width) / 3,
              y: height * 0.75,
            });

          // keep track of assigned expected positions
          const assigned = {};

          for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < minArea) continue;
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            if (approx.rows === 4 && cv.isContourConvex(approx)) {
              let childIdx = -1;
              if (hierArr) childIdx = hierArr[i * 4 + 2];
              if (childIdx !== -1) {
                let childCnt = contours.get(childIdx);
                let childArea = cv.contourArea(childCnt);
                if (
                  childArea > 0 &&
                  childArea / area > 0.01 &&
                  childArea / area < 0.9
                ) {
                  let cPeri = cv.arcLength(childCnt, true);
                  let cApprox = new cv.Mat();
                  cv.approxPolyDP(childCnt, cApprox, 0.02 * cPeri, true);
                  if (cApprox.rows === 4 && cv.isContourConvex(cApprox)) {
                    // centroid of inner contour
                    let m = cv.moments(childCnt);
                    let cx = 0,
                      cy = 0;
                    if (m.m00 && m.m00 !== 0) {
                      cx = m.m10 / m.m00;
                      cy = m.m01 / m.m00;
                    } else {
                      let r = cv.boundingRect(childCnt);
                      cx = r.x + r.width / 2;
                      cy = r.y + r.height / 2;
                    }

                    // find nearest expected position
                    let best = null;
                    let bestDist = Infinity;
                    for (let k = 0; k < expectedPositions.length; k++) {
                      const ep = expectedPositions[k];
                      const dx = ep.x - cx,
                        dy = ep.y - cy;
                      const d = Math.hypot(dx, dy);
                      if (d < bestDist) {
                        bestDist = d;
                        best = { ep, k, d };
                      }
                    }

                    // threshold: accept if within reasonable distance (~width/6)
                    const acceptTh = Math.max(20, Math.min(width, height) / 6);
                    let regionLabel = null;
                    if (best && best.d <= acceptTh) {
                      // if already assigned, keep the closer one
                      if (!assigned[best.k] || assigned[best.k].dist > best.d) {
                        assigned[best.k] = { idx: i, dist: best.d };
                        regionLabel = best.ep.label;
                      } else {
                        regionLabel = best.ep.label; // still label but duplicates may exist, we'll resolve later
                      }
                    } else {
                      // fallback: use top/bottom third based on x
                      if (cy < height / 2) {
                        if (cx < width / 3) regionLabel = "TL";
                        else if (cx < (2 * width) / 3) regionLabel = "TM";
                        else regionLabel = "TR";
                      } else {
                        if (cx < width / 3) regionLabel = "BL";
                        else if (cx < (2 * width) / 3) regionLabel = "BM";
                        else regionLabel = "BR";
                      }
                    }

                    markerCount++;
                    innerAreas.push(childArea);
                    normalMarkers.push({
                      outerIdx: i,
                      innerIdx: childIdx,
                      innerArea: childArea,
                      cx: cx,
                      cy: cy,
                      label: regionLabel,
                    });

                    cv.drawContours(
                      dst,
                      contours,
                      i,
                      new cv.Scalar(0, 255, 0, 255),
                      2,
                      cv.LINE_8,
                      hierarchy,
                      0
                    );
                    cv.drawContours(
                      dst,
                      contours,
                      childIdx,
                      new cv.Scalar(0, 128, 255, 255),
                      2,
                      cv.LINE_8
                    );
                    cv.putText(
                      dst,
                      regionLabel,
                      new cv.Point(Math.round(cx) - 12, Math.round(cy) - 12),
                      cv.FONT_HERSHEY_SIMPLEX,
                      0.7,
                      new cv.Scalar(255, 255, 255, 255),
                      2
                    );
                  }
                  cApprox.delete();
                }
              }
            }
            approx.delete();
          }

          // Average inner area (use median to be robust)
          let avgInnerArea = 0;
          let medianInnerArea = 0;
          if (innerAreas.length > 0) {
            avgInnerArea =
              innerAreas.reduce((a, b) => a + b, 0) / innerAreas.length;
            // median
            let sorted = innerAreas.slice().sort((a, b) => a - b);
            let mid = Math.floor(sorted.length / 2);
            medianInnerArea =
              sorted.length % 2 !== 0
                ? sorted[mid]
                : (sorted[mid - 1] + sorted[mid]) / 2;
          }

          // Deduplicate markers: if multiple detected markers were assigned the
          // same expected label (e.g., BR twice), keep only the one closest to
          // the expected position. Also include unassigned markers that don't
          // conflict with chosen ones.
          (function dedupeAssignedMarkers() {
            const expectedLabels = expectedPositions.map((e) => e.label);
            const uniqueNormals = [];

            for (let k = 0; k < expectedPositions.length; k++) {
              const ep = expectedPositions[k];
              const candidates = normalMarkers.filter(
                (n) => n.label === ep.label
              );
              if (candidates.length === 0) continue;
              let best = candidates[0];
              let bestD = Math.hypot(best.cx - ep.x, best.cy - ep.y);
              for (let i = 1; i < candidates.length; i++) {
                const c = candidates[i];
                const d = Math.hypot(c.cx - ep.x, c.cy - ep.y);
                if (d < bestD) {
                  best = c;
                  bestD = d;
                }
              }
              uniqueNormals.push(best);
            }

            // Add any other normalMarkers that weren't chosen above (different labels)
            for (const n of normalMarkers) {
              const exists = uniqueNormals.some(
                (u) => u.cx === n.cx && u.cy === n.cy
              );
              if (!exists) {
                // If the label is one of the expected labels but wasn't chosen,
                // skip it; otherwise include it (fallback/labeled by y/x)
                if (!expectedLabels.includes(n.label)) uniqueNormals.push(n);
              }
            }

            normalMarkers = uniqueNormals;
            // update markerCount to reflect deduped normals
            markerCount = normalMarkers.length;
          })();

          

          

          // No special-marker workflow: we expect 6 equal markers (3 top, 3 bottom)
          cv.putText(
            dst,
            "Marcadores detectados: " + markerCount,
            new cv.Point(10, 30),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 255, 0, 255),
            2
          );

          cv.imshow("canvasOutput", dst);

          

          // Draw code matrix grid (10x10) when we have the 6 markers labeled
          (function drawCodeMatrixIfPresent() {
            try {
              // need TL, TM, TR, BL, BM, BR
              const needed = ["TL", "TM", "TR", "BL", "BM", "BR"];
              const labelMap = {};
              for (const nm of normalMarkers) {
                if (nm && nm.label) labelMap[nm.label] = { x: nm.cx, y: nm.cy };
              }
              const hasAll = needed.every((l) => !!labelMap[l]);
              if (!hasAll) return;

              // compute corners: prefer using cornerWeights from template (relative to 6 markers)
              const detectedOrder = ["TL", "TM", "TR", "BL", "BM", "BR"].map(
                (l) => labelMap[l]
              );

              let TL = labelMap["TL"];
              let TR = labelMap["TR"];
              let BL = labelMap["BL"];
              let BR = labelMap["BR"];

              if (
                matrixTemplate &&
                matrixTemplate.cornerWeights &&
                Object.keys(matrixTemplate.cornerWeights).length >= 4
              ) {
                function applyWeights(w) {
                  let x = 0,
                    y = 0;
                  for (let i = 0; i < 6; i++) {
                    const m = detectedOrder[i];
                    if (!m) continue;
                    const wi = w[i] || 0;
                    x += wi * m.x;
                    y += wi * m.y;
                  }
                  return { x, y };
                }
                try {
                  const cw = matrixTemplate.cornerWeights;
                  if (cw.CTL) TL = applyWeights(cw.CTL);
                  if (cw.CTR) TR = applyWeights(cw.CTR);
                  if (cw.CBL) BL = applyWeights(cw.CBL);
                  if (cw.CBR) BR = applyWeights(cw.CBR);
                } catch (err) {
                  console.warn("failed to apply corner weights", err);
                }
              }

              // draw a light polygon showing region
              ctx.save();
              ctx.strokeStyle = "rgba(255,255,0,0.8)";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(TL.x, TL.y);
              ctx.lineTo(TR.x, TR.y);
              ctx.lineTo(BR.x, BR.y);
              ctx.lineTo(BL.x, BL.y);
              ctx.closePath();
              ctx.stroke();

              // bilinear interpolation across the quad for a 10x10 grid
              const rows = 10,
                cols = 10;

              // visual radius for grid points on live canvas (10% larger)
              const baseGridRadius = 3;
              const gridPointRadius = Math.ceil(baseGridRadius * 1.1);

              // determine template extents (u/v in [0,1]) if available
              let umin = 0,
                umax = 1,
                vmin = 0,
                vmax = 1;
              if (
                matrixTemplate &&
                matrixTemplate.points &&
                matrixTemplate.points.length > 0
              ) {
                umin = matrixTemplate.umin;
                umax = matrixTemplate.umax;
                vmin = matrixTemplate.vmin;
                vmax = matrixTemplate.vmax;
              }

              // If user supplied only 4 circle percents, draw those 4 points and return
              if (
                typeof circleTemplate !== "undefined" &&
                circleTemplate &&
                circleTemplate.circles
              ) {
                try {
                  // compute the four circle corners in image coordinates
                  const cKeys = ["CTL", "CTR", "CBL", "CBR"];
                  const circlesPos = {};
                  for (const key of cKeys) {
                    const pct = circleTemplate.circles[key];
                    if (!pct) continue;
                    const u = (pct.percent_x || 0) / 100.0;
                    const v = (pct.percent_y || 0) / 100.0;
                    const x =
                      (1 - u) * (1 - v) * TL.x +
                      u * (1 - v) * TR.x +
                      (1 - u) * v * BL.x +
                      u * v * BR.x;
                    const y =
                      (1 - u) * (1 - v) * TL.y +
                      u * (1 - v) * TR.y +
                      (1 - u) * v * BL.y +
                      u * v * BR.y;
                    circlesPos[key] = { x, y };
                  }

                  // only draw the full 10x10 grid inside the area defined by CTL,CTR,CBL,CBR
                  if (
                    circlesPos.CTL &&
                    circlesPos.CTR &&
                    circlesPos.CBL &&
                    circlesPos.CBR
                  ) {
                    const rowsT = 10,
                      colsT = 10;
                    for (let r = 0; r < rowsT; r++) {
                      const v = rowsT === 1 ? 0 : r / (rowsT - 1);
                      for (let c = 0; c < colsT; c++) {
                        const u = colsT === 1 ? 0 : c / (colsT - 1);
                        const x =
                          (1 - u) * (1 - v) * circlesPos.CTL.x +
                          u * (1 - v) * circlesPos.CTR.x +
                          (1 - u) * v * circlesPos.CBL.x +
                          u * v * circlesPos.CBR.x;
                        const y =
                          (1 - u) * (1 - v) * circlesPos.CTL.y +
                          u * (1 - v) * circlesPos.CTR.y +
                          (1 - u) * v * circlesPos.CBL.y +
                          u * v * circlesPos.CBR.y;
                        ctx.beginPath();
                        ctx.fillStyle = "rgba(255,220,0,0.95)";
                        ctx.arc(
                          Math.round(x),
                          Math.round(y),
                          gridPointRadius,
                          0,
                          Math.PI * 2
                        );
                        ctx.fill();
                      }
                    }
                  }

                  // highlight the 4 template circles on top
                  for (const key of Object.keys(circleTemplate.circles)) {
                    const p = circlesPos[key];
                    if (!p) continue;
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(0,255,128,0.95)";
                    ctx.arc(
                      Math.round(p.x),
                      Math.round(p.y),
                      6,
                      0,
                      Math.PI * 2
                    );
                    ctx.fill();
                    ctx.fillStyle = "#000";
                    ctx.font = "14px monospace";
                    ctx.fillText(key, Math.round(p.x) + 8, Math.round(p.y) - 8);
                  }
                  // draw any additional matrices defined in circleTemplate as M*Questions
                  try {
                    const matrixKeys = Object.keys(circleTemplate).filter((k) =>
                      /^M\d+Questions$/.test(k)
                    );
                    for (const mk of matrixKeys) {
                      const def = circleTemplate[mk];
                      const rowsT = def.rows || 10;
                      const colsT = def.cols || 8;
                      const mc = {};
                      // compute the 4 circle corners for this matrix in image coords
                      for (const key of ["CTL", "CTR", "CBL", "CBR"]) {
                        const pct = def.circles && def.circles[key];
                        if (!pct) continue;
                        const u = (pct.percent_x || 0) / 100.0;
                        const v = (pct.percent_y || 0) / 100.0;
                        const x =
                          (1 - u) * (1 - v) * TL.x +
                          u * (1 - v) * TR.x +
                          (1 - u) * v * BL.x +
                          u * v * BR.x;
                        const y =
                          (1 - u) * (1 - v) * TL.y +
                          u * (1 - v) * TR.y +
                          (1 - u) * v * BL.y +
                          u * v * BR.y;
                        mc[key] = { x, y };
                      }
                      if (!(mc.CTL && mc.CTR && mc.CBL && mc.CBR)) continue;
                      // draw grid points for this matrix
                      for (let r = 0; r < rowsT; r++) {
                        const v = rowsT === 1 ? 0 : r / (rowsT - 1);
                        for (let c = 0; c < colsT; c++) {
                          const u = colsT === 1 ? 0 : c / (colsT - 1);
                          const x =
                            (1 - u) * (1 - v) * mc.CTL.x +
                            u * (1 - v) * mc.CTR.x +
                            (1 - u) * v * mc.CBL.x +
                            u * v * mc.CBR.x;
                          const y =
                            (1 - u) * (1 - v) * mc.CTL.y +
                            u * (1 - v) * mc.CTR.y +
                            (1 - u) * v * mc.CBL.y +
                            u * v * mc.CBR.y;
                          ctx.beginPath();
                          ctx.fillStyle = "rgba(255,200,0,0.95)"; // slightly different yellow
                          ctx.arc(
                            Math.round(x),
                            Math.round(y),
                            gridPointRadius,
                            0,
                            Math.PI * 2
                          );
                          ctx.fill();
                        }
                      }
                    }
                  } catch (err) {
                    /* ignore extra matrix drawing errors */
                  }
                } catch (err) {
                  console.warn("failed drawing circleTemplate points", err);
                }
              } else {
                for (let r = 0; r < rows; r++) {
                  const v =
                    rows === 1 ? vmin : vmin + (vmax - vmin) * (r / (rows - 1));
                  for (let c = 0; c < cols; c++) {
                    const u =
                      cols === 1
                        ? umin
                        : umin + (umax - umin) * (c / (cols - 1));
                    // bilinear: P(u,v) = (1-u)(1-v)*TL + u(1-v)*TR + (1-u)v*BL + u v * BR
                    const x =
                      (1 - u) * (1 - v) * TL.x +
                      u * (1 - v) * TR.x +
                      (1 - u) * v * BL.x +
                      u * v * BR.x;
                    const y =
                      (1 - u) * (1 - v) * TL.y +
                      u * (1 - v) * TR.y +
                      (1 - u) * v * BL.y +
                      u * v * BR.y;
                    // draw point
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(255,220,0,0.95)";
                    ctx.arc(
                      Math.round(x),
                      Math.round(y),
                      gridPointRadius,
                      0,
                      Math.PI * 2
                    );
                    ctx.fill();
                  }
                }
              }
              ctx.restore();
            } catch (err) {
              /* ignore drawing errors */
            }
          })();

          // If all 6 markers detected, capture last frame (with marks) once
          let totalDetected = markerCount;
          if (totalDetected >= 6 && !captured) {
            captured = true;
            // prepare final lists
            let finalNormals = normalMarkers.slice();

            // capture image: prefer the processed (alto contraste) frame without overlays
            const dataURL =
              lastProcessedDataURL ||
              lastCleanDataURL ||
              canvas.toDataURL("image/png");

            let rot = 0;

            // show snapshot overlay
            createSnapshotOverlay(dataURL, rot, finalNormals, width, height);
          }

          // cleanup
          dst.delete();
          contours.delete();
          hierarchy.delete();

          if (!captured) requestAnimationFrame(loop);
        }

        function createSnapshotOverlay(
          dataURL,
          rotationDeg,
          normals,
          srcW,
          srcH
        ) {
          // remove existing overlay if any
          const existing = document.getElementById("omrSnapshotOverlay");
          if (existing) existing.remove();

          const overlay = document.createElement("div");
          overlay.id = "omrSnapshotOverlay";
          overlay.style.position = "fixed";
          overlay.style.left = "0";
          overlay.style.top = "0";
          overlay.style.width = "100%";
          overlay.style.height = "100%";
          overlay.style.display = "flex";
          overlay.style.alignItems = "center";
          overlay.style.justifyContent = "center";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.zIndex = 9999;

          const panel = document.createElement("div");
          panel.style.background = "#222";
          panel.style.padding = "12px";
          panel.style.borderRadius = "8px";
          panel.style.color = "#fff";
          panel.style.maxWidth = "95%";
          panel.style.maxHeight = "95%";
          panel.style.overflow = "auto";

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "Cerrar y continuar";
          closeBtn.style.marginBottom = "8px";
          closeBtn.onclick = () => {
            overlay.remove();
            // resume loop
            captured = false;
            try {
              loop();
            } catch (e) {
              /* ignore */
            }
          };

          const info = document.createElement("div");
          info.style.display = "flex";
          info.style.gap = "12px";

          const canvasWrap = document.createElement("div");
          const snapCanvas = document.createElement("canvas");
          snapCanvas.style.maxWidth = "80vw";
          snapCanvas.style.maxHeight = "80vh";
          canvasWrap.appendChild(snapCanvas);

          const list = document.createElement("div");
          list.style.minWidth = "220px";
          list.style.fontFamily = "monospace";

          const title = document.createElement("div");
          title.textContent = "Snapshot - coordenadas (px)";
          title.style.marginBottom = "8px";
          list.appendChild(title);

          const ul = document.createElement("ul");
          list.appendChild(ul);

          info.appendChild(canvasWrap);
          info.appendChild(list);
          panel.appendChild(closeBtn);
          panel.appendChild(info);
          overlay.appendChild(panel);
          document.body.appendChild(overlay);

          const img = new Image();
          img.onload = () => {
            snapCanvas.width = img.width;
            snapCanvas.height = img.height;
            const sctx = snapCanvas.getContext("2d");
            sctx.drawImage(img, 0, 0);
            const cleanSnapDataURL = snapCanvas.toDataURL("image/png");

            const labelMap = {};
            normals.forEach((n) => {
              labelMap[n.label] = { x: n.cx, y: n.cy };
              const li = document.createElement("li");
              li.textContent = `${n.label}: ${Math.round(n.cx)}, ${Math.round(
                n.cy
              )}`;
              ul.appendChild(li);
            });

            // No special marker in 6-marker workflow

            // draw connection lines for visualization
            function drawLine(a, b, color) {
              if (a && b) {
                sctx.strokeStyle = color || "#0f0";
                sctx.lineWidth = 2;
                sctx.beginPath();
                sctx.moveTo(a.x, a.y);
                sctx.lineTo(b.x, b.y);
                sctx.stroke();
              }
            }
            drawLine(labelMap["TL"], labelMap["TM"], "#88f");
            drawLine(labelMap["TM"], labelMap["TR"], "#88f");
            drawLine(labelMap["BL"], labelMap["BM"], "#88f");
            drawLine(labelMap["BM"], labelMap["BR"], "#88f");
            drawLine(labelMap["TL"], labelMap["BL"], "#8f8");
            drawLine(labelMap["TM"], labelMap["BM"], "#8f8");
            drawLine(labelMap["TR"], labelMap["BR"], "#8f8");

            // If we have the four corners (TL,TR,BL,BR) perform perspective correction
            const required = ["TL", "TR", "BL", "BR"];
            const hasAll = required.every((l) => !!labelMap[l]);
            if (hasAll && typeof cv !== "undefined") {
              try {
                function dist(a, b) {
                  const dx = a.x - b.x,
                    dy = a.y - b.y;
                  return Math.hypot(dx, dy);
                }
                const topW = dist(labelMap["TL"], labelMap["TR"]);
                const botW = dist(labelMap["BL"], labelMap["BR"]);
                const leftH = dist(labelMap["TL"], labelMap["BL"]);
                const rightH = dist(labelMap["TR"], labelMap["BR"]);
                const dstW = Math.max(1, Math.round((topW + botW) / 2));
                const dstH = Math.max(1, Math.round((leftH + rightH) / 2));
                // upscale factor for higher-resolution corrected image
                const scale = 2; // change to 1,2,3 as needed. Higher = larger image and more detail.
                const dstWScaled = Math.max(1, Math.round(dstW * scale));
                const dstHScaled = Math.max(1, Math.round(dstH * scale));

                const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  labelMap["TL"].x,
                  labelMap["TL"].y,
                  labelMap["TR"].x,
                  labelMap["TR"].y,
                  labelMap["BL"].x,
                  labelMap["BL"].y,
                  labelMap["BR"].x,
                  labelMap["BR"].y,
                ]);
                // destination uses scaled size for higher resolution
                const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  0,
                  0,
                  dstWScaled,
                  0,
                  0,
                  dstHScaled,
                  dstWScaled,
                  dstHScaled,
                ]);

                let srcMat = cv.imread(snapCanvas);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                let dstMat = new cv.Mat();
                let dsize = new cv.Size(dstWScaled, dstHScaled);
                cv.warpPerspective(
                  srcMat,
                  dstMat,
                  M,
                  dsize,
                  cv.INTER_CUBIC,
                  cv.BORDER_CONSTANT,
                  new cv.Scalar()
                );

                const corrected = document.createElement("canvas");
                corrected.width = dstWScaled;
                corrected.height = dstHScaled;
                corrected.style.maxWidth = "80vw";
                corrected.style.display = "block";
                const corrWrap = document.createElement("div");
                corrWrap.style.marginTop = "8px";
                corrWrap.appendChild(corrected);
                canvasWrap.appendChild(corrWrap);
                cv.imshow(corrected, dstMat);
                // capture clean corrected image (no overlays)
                const cleanCorrectedDataURL = corrected.toDataURL("image/png");

                // redraw overlays (markers and lines) on the rotated snapshot canvas WITHOUT affecting srcMat
                try {
                  // redraw markers and labels on snapCanvas for user (these are only visual)
                  sctx.save();
                  sctx.fillStyle = "cyan";
                  sctx.strokeStyle = "#88f";
                  sctx.lineWidth = 2;
                  for (const key of Object.keys(labelMap)) {
                    const p = labelMap[key];
                    if (!p) continue;
                    sctx.beginPath();
                    sctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    sctx.fillStyle = "cyan";
                    sctx.fill();
                    sctx.fillStyle = "#fff";
                    sctx.font = "14px monospace";
                    sctx.fillText(key + ` (${p.x},${p.y})`, p.x + 8, p.y - 8);
                  }
                  // redraw connection lines
                  function drawLine(a, b, color) {
                    if (a && b) {
                      sctx.strokeStyle = color || "#0f0";
                      sctx.lineWidth = 2;
                      sctx.beginPath();
                      sctx.moveTo(a.x, a.y);
                      sctx.lineTo(b.x, b.y);
                      sctx.stroke();
                    }
                  }
                  drawLine(labelMap["TL"], labelMap["TM"], "#88f");
                  drawLine(labelMap["TM"], labelMap["TR"], "#88f");
                  drawLine(labelMap["BL"], labelMap["BM"], "#88f");
                  drawLine(labelMap["BM"], labelMap["BR"], "#88f");
                  drawLine(labelMap["TL"], labelMap["BL"], "#8f8");
                  drawLine(labelMap["TM"], labelMap["BM"], "#8f8");
                  drawLine(labelMap["TR"], labelMap["BR"], "#8f8");
                  sctx.restore();
                  // capture overlay snapshot (with drawn markers) for toggle
                  const overlaySnapDataURL = snapCanvas.toDataURL("image/png");
                } catch (err) {
                  console.warn("failed to redraw snapshot overlays", err);
                }

                // detect filled circles inside the corrected image (use dstMat which has NO overlays)
                try {
                  const rowsT = 10,
                    colsT = 10;
                  // build source grid points (in src/snapshot coordinates) inside the 4 template circles
                  const circleKeys = ["CTL", "CTR", "CBL", "CBR"];
                  const circlesSrc = {};
                  if (
                    typeof circleTemplate !== "undefined" &&
                    circleTemplate &&
                    circleTemplate.circles
                  ) {
                    for (const k of circleKeys) {
                      const pct = circleTemplate.circles[k];
                      if (!pct) continue;
                      const u = (pct.percent_x || 0) / 100.0;
                      const v = (pct.percent_y || 0) / 100.0;
                      const x =
                        (1 - u) * (1 - v) * labelMap["TL"].x +
                        u * (1 - v) * labelMap["TR"].x +
                        (1 - u) * v * labelMap["BL"].x +
                        u * v * labelMap["BR"].x;
                      const y =
                        (1 - u) * (1 - v) * labelMap["TL"].y +
                        u * (1 - v) * labelMap["TR"].y +
                        (1 - u) * v * labelMap["BL"].y +
                        u * v * labelMap["BR"].y;
                      circlesSrc[k] = { x, y };
                    }
                  }

                  // only proceed if we have the four defining circle centers in source coords
                  if (
                    circlesSrc.CTL &&
                    circlesSrc.CTR &&
                    circlesSrc.CBL &&
                    circlesSrc.CBR
                  ) {
                    // create list of src points for grid
                    const srcPtsArr = [];
                    for (let r = 0; r < rowsT; r++) {
                      const v = rowsT === 1 ? 0 : r / (rowsT - 1);
                      for (let c = 0; c < colsT; c++) {
                        const u = colsT === 1 ? 0 : c / (colsT - 1);
                        const x =
                          (1 - u) * (1 - v) * circlesSrc.CTL.x +
                          u * (1 - v) * circlesSrc.CTR.x +
                          (1 - u) * v * circlesSrc.CBL.x +
                          u * v * circlesSrc.CBR.x;
                        const y =
                          (1 - u) * (1 - v) * circlesSrc.CTL.y +
                          u * (1 - v) * circlesSrc.CTR.y +
                          (1 - u) * v * circlesSrc.CBL.y +
                          u * v * circlesSrc.CBR.y;
                        srcPtsArr.push(x);
                        srcPtsArr.push(y);
                      }
                    }

                    // transform to corrected image coords using M
                    const srcPts = cv.matFromArray(
                      rowsT * colsT,
                      1,
                      cv.CV_32FC2,
                      srcPtsArr
                    );
                    const dstPts = new cv.Mat();
                    cv.perspectiveTransform(srcPts, dstPts, M);

                    // prepare gray version of dstMat for intensity sampling
                    const gray = new cv.Mat();
                    cv.cvtColor(dstMat, gray, cv.COLOR_RGBA2GRAY);
                    // optional blur to reduce noise
                    cv.GaussianBlur(gray, gray, new cv.Size(3, 3), 0);

                    const data = dstPts.data32F;
                    const darkThresh = 100; // intensity <= this considered dark
                    const requiredFraction = 0.5;
                    // base visual radius used previously on canvas (small)
                    const baseGridRadius = 3;
                    // display radius scaled to corrected image and increased by 10%
                    const displayRadius = Math.max(
                      3,
                      Math.round(baseGridRadius * (dstWScaled / dstW) * 1.1)
                    );
                    // use same radius for sampling neighborhood
                    const localRadius = displayRadius;

                    const detectedPoints = [];
                    const darkCounts = [];
                    const totalCounts = [];
                    const fractions = [];
                    for (let i = 0; i < data.length; i += 2) {
                      const dx = Math.round(data[i]);
                      const dy = Math.round(data[i + 1]);
                      if (
                        dx < 0 ||
                        dy < 0 ||
                        dx >= dstWScaled ||
                        dy >= dstHScaled
                      ) {
                        detectedPoints.push(false);
                        continue;
                      }
                      // sample circular neighborhood
                      let darkCount = 0;
                      let totalCount = 0;
                      const r = localRadius;
                      const r2 = r * r;
                      const xmin = Math.max(0, dx - r);
                      const xmax = Math.min(dstWScaled - 1, dx + r);
                      const ymin = Math.max(0, dy - r);
                      const ymax = Math.min(dstHScaled - 1, dy + r);
                      for (let yy = ymin; yy <= ymax; yy++) {
                        const rowPtr = gray.ucharPtr(yy);
                        for (let xx = xmin; xx <= xmax; xx++) {
                          const ddx = xx - dx;
                          const ddy = yy - dy;
                          if (ddx * ddx + ddy * ddy > r2) continue;
                          totalCount++;
                          const v = rowPtr[xx];
                          if (v <= darkThresh) darkCount++;
                        }
                      }
                      const frac = totalCount > 0 ? darkCount / totalCount : 0;
                      detectedPoints.push(frac >= requiredFraction);
                      darkCounts.push(darkCount);
                      totalCounts.push(totalCount);
                      fractions.push(frac);
                    }

                    // draw detections on corrected canvas and list coordinates
                    const cctx = corrected.getContext("2d");
                    // first draw all grid points in yellow with displayRadius
                    cctx.fillStyle = "rgba(255,220,0,0.95)";
                    for (let i = 0; i < data.length; i += 2) {
                      const gx = Math.round(data[i]);
                      const gy = Math.round(data[i + 1]);
                      if (
                        gx < 0 ||
                        gy < 0 ||
                        gx >= dstWScaled ||
                        gy >= dstHScaled
                      )
                        continue;
                      cctx.beginPath();
                      cctx.arc(gx, gy, displayRadius, 0, Math.PI * 2);
                      cctx.fill();
                    }

                    // then prepare overlay list and draw red markers for detected ones
                    cctx.fillStyle = "rgba(255,0,0,0.95)";
                    // Build a table 10x10 with dark/total counts and fraction for each cell
                    const tableWrap = document.createElement("div");
                    tableWrap.style.marginTop = "6px";
                    tableWrap.style.color = "#fff";
                    tableWrap.style.fontFamily = "monospace";
                    const title = document.createElement("div");
                    title.textContent =
                      "Grid dark/total counts (dark/total, pct)";
                    tableWrap.appendChild(title);
                    const table = document.createElement("table");
                    table.style.borderCollapse = "collapse";
                    table.style.marginTop = "6px";
                    table.style.background = "rgba(0,0,0,0.6)";
                    table.style.color = "#fff";
                    const rowsEl = rowsT;
                    const colsEl = colsT;
                    let idx = 0;
                    for (let r = 0; r < rowsEl; r++) {
                      const tr = document.createElement("tr");
                      for (let c = 0; c < colsEl; c++) {
                        const td = document.createElement("td");
                        td.style.border = "1px solid rgba(255,255,255,0.1)";
                        td.style.padding = "4px 6px";
                        const dark = darkCounts[idx] || 0;
                        const tot = totalCounts[idx] || 0;
                        const pct =
                          tot > 0 ? Math.round((dark / tot) * 100) : 0;
                        td.textContent = `${dark}/${tot} (${pct}%)`;
                        tr.appendChild(td);
                        idx++;
                      }
                      table.appendChild(tr);
                    }
                    tableWrap.appendChild(table);
                    corrWrap.appendChild(tableWrap);

                    // compute the 10-digit code based on detected red points
                    try {
                      const codeDigits = [];
                      for (let c = 0; c < colsT; c++) {
                        let bestRow = -1;
                        let bestFrac = -1;
                        for (let r = 0; r < rowsT; r++) {
                          const i = r * colsT + c;
                          const frac = fractions[i] || 0;
                          if (detectedPoints[i]) {
                            if (frac > bestFrac) {
                              bestFrac = frac;
                              bestRow = r;
                            }
                          }
                        }
                        // if no red point or red point is on last row (row 10), digit = 0
                        let digit = 0;
                        if (bestRow !== -1 && bestRow !== rowsT - 1) {
                          digit = bestRow + 1; // rows are 0-based -> digit = rowIndex+1
                        }
                        codeDigits.push(digit);
                      }

                      const codeWrap = document.createElement("div");
                      codeWrap.style.marginTop = "8px";
                      codeWrap.style.color = "#fff";
                      codeWrap.style.fontFamily = "monospace";

                      const codeTitle = document.createElement("div");
                      codeTitle.textContent = "CÃ³digo:";
                      codeTitle.style.fontWeight = "bold";
                      codeTitle.style.marginBottom = "6px";
                      codeWrap.appendChild(codeTitle);

                      const codeValue = document.createElement("div");
                      codeValue.textContent = codeDigits.join("");
                      codeValue.style.fontSize = "20px";
                      codeValue.style.letterSpacing = "4px";
                      codeWrap.appendChild(codeValue);

                      corrWrap.appendChild(codeWrap);
                    } catch (err) {
                      console.warn("failed to compute code", err);
                    }

                    // draw red markers for detected ones and keep yellow background already drawn
                    idx = 0;
                    for (let r = 0; r < rowsT; r++) {
                      for (let c = 0; c < colsT; c++) {
                        const px = Math.round(dstPts.data32F[idx * 2]);
                        const py = Math.round(dstPts.data32F[idx * 2 + 1]);
                        if (detectedPoints[idx]) {
                          cctx.beginPath();
                          cctx.arc(px, py, displayRadius, 0, Math.PI * 2);
                          cctx.fillStyle = "rgba(255,0,0,0.95)";
                          cctx.fill();
                          cctx.fillStyle = "rgba(255,0,0,0.95)";
                        }
                        idx++;
                      }
                    }

                    // cleanup mats
                    srcPts.delete();
                    dstPts.delete();
                    gray.delete();
                  }
                } catch (err) {
                  console.warn("filled-circle detection failed", err);
                }

                // process any additional M*Questions matrices defined in circleTemplate
                try {
                  const matrixKeys = Object.keys(circleTemplate || {}).filter(
                    (k) => /^M\d+Questions$/.test(k)
                  );
                  if (matrixKeys.length > 0) {
                    const cctx = corrected.getContext("2d");
                    for (const mk of matrixKeys) {
                      try {
                        const def = circleTemplate[mk];
                        const rowsM = def.rows || 10;
                        const colsM = def.cols || 8;
                        // build source circle centers for this matrix in snapshot coords
                        const circleKeys = ["CTL", "CTR", "CBL", "CBR"];
                        const circlesSrcM = {};
                        if (def && def.circles) {
                          for (const k of circleKeys) {
                            const pct = def.circles[k];
                            if (!pct) continue;
                            const u = (pct.percent_x || 0) / 100.0;
                            const v = (pct.percent_y || 0) / 100.0;
                            const x =
                              (1 - u) * (1 - v) * labelMap["TL"].x +
                              u * (1 - v) * labelMap["TR"].x +
                              (1 - u) * v * labelMap["BL"].x +
                              u * v * labelMap["BR"].x;
                            const y =
                              (1 - u) * (1 - v) * labelMap["TL"].y +
                              u * (1 - v) * labelMap["TR"].y +
                              (1 - u) * v * labelMap["BL"].y +
                              u * v * labelMap["BR"].y;
                            circlesSrcM[k] = { x, y };
                          }
                        }

                        if (
                          !(
                            circlesSrcM.CTL &&
                            circlesSrcM.CTR &&
                            circlesSrcM.CBL &&
                            circlesSrcM.CBR
                          )
                        )
                          continue;

                        // create list of src points for this matrix
                        const srcPtsArrM = [];
                        for (let r = 0; r < rowsM; r++) {
                          const v = rowsM === 1 ? 0 : r / (rowsM - 1);
                          for (let c = 0; c < colsM; c++) {
                            const u = colsM === 1 ? 0 : c / (colsM - 1);
                            const x =
                              (1 - u) * (1 - v) * circlesSrcM.CTL.x +
                              u * (1 - v) * circlesSrcM.CTR.x +
                              (1 - u) * v * circlesSrcM.CBL.x +
                              u * v * circlesSrcM.CBR.x;
                            const y =
                              (1 - u) * (1 - v) * circlesSrcM.CTL.y +
                              u * (1 - v) * circlesSrcM.CTR.y +
                              (1 - u) * v * circlesSrcM.CBL.y +
                              u * v * circlesSrcM.CBR.y;
                            srcPtsArrM.push(x);
                            srcPtsArrM.push(y);
                          }
                        }

                        // transform to corrected image coords using M
                        const srcPtsM = cv.matFromArray(
                          rowsM * colsM,
                          1,
                          cv.CV_32FC2,
                          srcPtsArrM
                        );
                        const dstPtsM = new cv.Mat();
                        cv.perspectiveTransform(srcPtsM, dstPtsM, M);

                        // prepare gray version of dstMat for intensity sampling
                        const grayM = new cv.Mat();
                        cv.cvtColor(dstMat, grayM, cv.COLOR_RGBA2GRAY);
                        cv.GaussianBlur(grayM, grayM, new cv.Size(3, 3), 0);

                        const dataM = dstPtsM.data32F;
                        const darkThreshM = 100; // same threshold as main
                        const requiredFractionM = 0.5; // same required fraction
                        const baseGridRadiusM = 3;
                        const displayRadiusM = Math.max(
                          3,
                          Math.round(
                            baseGridRadiusM * (dstWScaled / dstW) * 1.1
                          )
                        );
                        const localRadiusM = displayRadiusM;

                        const detectedPointsM = [];
                        const darkCountsM = [];
                        const totalCountsM = [];
                        const fractionsM = [];
                        for (let i = 0; i < dataM.length; i += 2) {
                          const dx = Math.round(dataM[i]);
                          const dy = Math.round(dataM[i + 1]);
                          if (
                            dx < 0 ||
                            dy < 0 ||
                            dx >= dstWScaled ||
                            dy >= dstHScaled
                          ) {
                            detectedPointsM.push(false);
                            darkCountsM.push(0);
                            totalCountsM.push(0);
                            fractionsM.push(0);
                            continue;
                          }
                          let darkCount = 0;
                          let totalCount = 0;
                          const r = localRadiusM;
                          const r2 = r * r;
                          const xmin = Math.max(0, dx - r);
                          const xmax = Math.min(dstWScaled - 1, dx + r);
                          const ymin = Math.max(0, dy - r);
                          const ymax = Math.min(dstHScaled - 1, dy + r);
                          for (let yy = ymin; yy <= ymax; yy++) {
                            const rowPtr = grayM.ucharPtr(yy);
                            for (let xx = xmin; xx <= xmax; xx++) {
                              const ddx = xx - dx;
                              const ddy = yy - dy;
                              if (ddx * ddx + ddy * ddy > r2) continue;
                              totalCount++;
                              const v = rowPtr[xx];
                              if (v <= darkThreshM) darkCount++;
                            }
                          }
                          const frac =
                            totalCount > 0 ? darkCount / totalCount : 0;
                          detectedPointsM.push(frac >= requiredFractionM);
                          darkCountsM.push(darkCount);
                          totalCountsM.push(totalCount);
                          fractionsM.push(frac);
                        }

                        // draw grid points for this matrix on corrected canvas
                        cctx.fillStyle = "rgba(255,200,0,0.95)";
                        for (let i = 0; i < dataM.length; i += 2) {
                          const gx = Math.round(dataM[i]);
                          const gy = Math.round(dataM[i + 1]);
                          if (
                            gx < 0 ||
                            gy < 0 ||
                            gx >= dstWScaled ||
                            gy >= dstHScaled
                          )
                            continue;
                          cctx.beginPath();
                          cctx.arc(gx, gy, displayRadiusM, 0, Math.PI * 2);
                          cctx.fill();
                        }

                        // draw red markers for detected ones
                        cctx.fillStyle = "rgba(255,0,0,0.95)";
                        let idxM = 0;
                        for (let r = 0; r < rowsM; r++) {
                          for (let c = 0; c < colsM; c++) {
                            const px = Math.round(dstPtsM.data32F[idxM * 2]);
                            const py = Math.round(
                              dstPtsM.data32F[idxM * 2 + 1]
                            );
                            if (detectedPointsM[idxM]) {
                              cctx.beginPath();
                              cctx.arc(px, py, displayRadiusM, 0, Math.PI * 2);
                              cctx.fill();
                            }
                            idxM++;
                          }
                        }

                        // Build result table and code for this matrix
                        const tableWrapM = document.createElement("div");
                        tableWrapM.style.marginTop = "6px";
                        tableWrapM.style.color = "#fff";
                        tableWrapM.style.fontFamily = "monospace";
                        const titleM = document.createElement("div");
                        titleM.textContent = mk + " - dark/total (pct)";
                        tableWrapM.appendChild(titleM);
                        const tableM = document.createElement("table");
                        tableM.style.borderCollapse = "collapse";
                        tableM.style.marginTop = "6px";
                        tableM.style.background = "rgba(0,0,0,0.6)";
                        tableM.style.color = "#fff";
                        let idx2 = 0;
                        for (let r = 0; r < rowsM; r++) {
                          const tr = document.createElement("tr");
                          for (let c = 0; c < colsM; c++) {
                            const td = document.createElement("td");
                            td.style.border = "1px solid rgba(255,255,255,0.1)";
                            td.style.padding = "4px 6px";
                            const dark = darkCountsM[idx2] || 0;
                            const tot = totalCountsM[idx2] || 0;
                            const pct =
                              tot > 0 ? Math.round((dark / tot) * 100) : 0;
                            td.textContent = `${dark}/${tot} (${pct}%)`;
                            tr.appendChild(td);
                            idx2++;
                          }
                          tableM.appendChild(tr);
                        }
                        tableWrapM.appendChild(tableM);
                        corrWrap.appendChild(tableWrapM);

                        // compute answers per row as JSON: [{question: row(1..N), answer: 'a'..}]
                        const answers = [];
                        for (let r = 0; r < rowsM; r++) {
                          let bestCol = -1;
                          let bestFrac = -1;
                          for (let c = 0; c < colsM; c++) {
                            const i = r * colsM + c;
                            const frac = fractionsM[i] || 0;
                            if (detectedPointsM[i]) {
                              if (frac > bestFrac) {
                                bestFrac = frac;
                                bestCol = c;
                              }
                            }
                          }
                          const answer =
                            bestCol === -1
                              ? ""
                              : String.fromCharCode(97 + bestCol); // 'a' + col
                          answers.push({ question: r + 1, answer });
                        }
                        const codeWrapM = document.createElement("div");
                        codeWrapM.style.marginTop = "8px";
                        codeWrapM.style.color = "#fff";
                        codeWrapM.style.fontFamily = "monospace";
                        const codeTitleM = document.createElement("div");
                        codeTitleM.textContent = mk + " Respuestas (JSON):";
                        codeTitleM.style.fontWeight = "bold";
                        codeTitleM.style.marginBottom = "6px";
                        codeWrapM.appendChild(codeTitleM);
                        const codeValueM = document.createElement("pre");
                        codeValueM.textContent = JSON.stringify(
                          answers,
                          null,
                          2
                        );
                        codeValueM.style.fontSize = "14px";
                        codeValueM.style.whiteSpace = "pre-wrap";
                        codeWrapM.appendChild(codeValueM);
                        corrWrap.appendChild(codeWrapM);

                        // cleanup mats for this matrix
                        srcPtsM.delete();
                        dstPtsM.delete();
                        grayM.delete();
                      } catch (err) {
                        console.warn("processing matrix failed", mk, err);
                      }
                    }
                  }
                } catch (err) {
                  console.warn("extra matrix processing failed", err);
                }

                // cleanup
                srcTri.delete();
                dstTri.delete();
                srcMat.delete();
                M.delete();
                dstMat.delete();
              } catch (err) {
                console.error("Persp transform failed", err);
              }
            }
          };
          img.src = dataURL;
        }

        loop();
      }
    </script>
  </body>
</html>
