<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Detector OMR en Tiempo Real</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f5f5f5;
        overflow-x: hidden;
      }
      .container {
        margin: 0 auto;
        padding: 10px;
      }
      .video-and-controls-wrapper {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }
      .video-container {
        max-width: 400px;
        max-height: 300px;
        margin: 0;
        background: #000;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #ccc;
      }
      #video {
        display: none;
      }
      #canvasOutput {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
      }
      canvas {
        display: block;
      }
      .contrast-slider-container {
        z-index: 10;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        margin-top: 20px;
      }
      .contrast-slider-container label {
        white-space: nowrap;
        margin-top: 10px;
      }
      .contrast-slider-container input[type="range"] {
        width: 200px;
        height: 20px;
        -webkit-appearance: none;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 5px;
      }
      .contrast-slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
      .contrast-slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4caf50;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸ“¹ Detector OMR - Vista Binaria</h1>
      <div id="status">Cargando OpenCV.js...</div>

      <div class="controls">
        <button id="stopBtn" class="stop" disabled style="display: none">
          Detener
        </button>
        <button id="retryBtn" disabled style="display: none">Reintentar</button>
      </div>

      <div class="video-and-controls-wrapper">
        <div class="video-container">
          <video
            id="video"
            autoplay
            playsinline
            width="640"
            height="480"
            style="display: none"
          ></video>
          <canvas id="canvasOutput" width="640" height="480"></canvas>
        </div>

        <div class="contrast-slider-container">
          <label
            >Contraste:
            <input id="contrast" type="range" min="0" max="200" value="100"
          /></label>
        </div>
      </div>
    </div>

    <script
      async
      src="https://docs.opencv.org/4.5.2/opencv.js"
      onload="onOpenCvReady()"
    ></script>

    <script>
      function onOpenCvReady() {
        startCamera();
      }

      function startCamera() {
        const video = document.getElementById("video");
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
              video.play();
              initOpenCV();
            };
          })
          .catch((err) => console.error(err));
      }

      function initOpenCV() {
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvasOutput");
        const ctx = canvas.getContext("2d");

        const width = video.videoWidth;
        const height = video.videoHeight;
        canvas.width = width;
        canvas.height = height;

        let src = new cv.Mat(height, width, cv.CV_8UC4);
        let gray = new cv.Mat(height, width, cv.CV_8UC1);
        let bw = new cv.Mat(height, width, cv.CV_8UC1);

        const contrastInput = document.getElementById("contrast");
        let contrastValue = parseFloat(contrastInput.value) / 100.0;
        contrastInput.oninput = () => {
          contrastValue = parseFloat(contrastInput.value) / 100.0;
        };
        contrastInput.addEventListener(
          "touchmove",
          (e) => {
            e.stopPropagation();
            e.preventDefault();
          },
          { passive: false }
        );

        let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
        let captured = false;

        function loop() {
          ctx.drawImage(video, 0, 0, width, height);
          let imageData = ctx.getImageData(0, 0, width, height);
          src.data.set(imageData.data);

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.convertScaleAbs(gray, gray, contrastValue, 0);
          cv.GaussianBlur(gray, gray, new cv.Size(3, 3), 0);
          clahe.apply(gray, gray);
          cv.threshold(gray, bw, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          // Detect contours
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(
            bw,
            contours,
            hierarchy,
            cv.RETR_TREE,
            cv.CHAIN_APPROX_SIMPLE
          );

          let dst = new cv.Mat();
          cv.cvtColor(bw, dst, cv.COLOR_GRAY2RGBA);

          // Detect normal markers (outer rect with inner rect), compute centroids and label regions
          let markerCount = 0;
          let innerAreas = [];
          let normalMarkers = []; // {outerIdx, innerIdx, innerArea, cx, cy, label}
          let hierArr = null;
          try {
            hierArr = hierarchy.data32S;
          } catch (e) {
            hierArr = null;
          }

          const minArea = Math.max(100, width * height * 0.0005);

          // Expected layout now: top row has 4 markers (TL, TM, E, TR)
          // bottom row has 3 markers (BL, BM, BR). We'll assign each detected
          // centroid to the nearest expected position to produce labels.
          const topLabels = ["TL", "TM", "E", "TR"];
          const bottomLabels = ["BL", "BM", "BR"];
          const expectedPositions = [];
          for (let i = 0; i < 4; i++)
            expectedPositions.push({
              label: topLabels[i],
              x: ((i + 0.5) * width) / 4,
              y: height * 0.25,
            });
          for (let i = 0; i < 3; i++)
            expectedPositions.push({
              label: bottomLabels[i],
              x: ((i + 0.5) * width) / 3,
              y: height * 0.75,
            });

          // keep track of assigned expected positions
          const assigned = {};

          for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area < minArea) continue;
            let peri = cv.arcLength(cnt, true);
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
            if (approx.rows === 4 && cv.isContourConvex(approx)) {
              let childIdx = -1;
              if (hierArr) childIdx = hierArr[i * 4 + 2];
              if (childIdx !== -1) {
                let childCnt = contours.get(childIdx);
                let childArea = cv.contourArea(childCnt);
                if (
                  childArea > 0 &&
                  childArea / area > 0.01 &&
                  childArea / area < 0.9
                ) {
                  let cPeri = cv.arcLength(childCnt, true);
                  let cApprox = new cv.Mat();
                  cv.approxPolyDP(childCnt, cApprox, 0.02 * cPeri, true);
                  if (cApprox.rows === 4 && cv.isContourConvex(cApprox)) {
                    // centroid of inner contour
                    let m = cv.moments(childCnt);
                    let cx = 0,
                      cy = 0;
                    if (m.m00 && m.m00 !== 0) {
                      cx = m.m10 / m.m00;
                      cy = m.m01 / m.m00;
                    } else {
                      let r = cv.boundingRect(childCnt);
                      cx = r.x + r.width / 2;
                      cy = r.y + r.height / 2;
                    }

                    // find nearest expected position
                    let best = null;
                    let bestDist = Infinity;
                    for (let k = 0; k < expectedPositions.length; k++) {
                      const ep = expectedPositions[k];
                      const dx = ep.x - cx,
                        dy = ep.y - cy;
                      const d = Math.hypot(dx, dy);
                      if (d < bestDist) {
                        bestDist = d;
                        best = { ep, k, d };
                      }
                    }

                    // threshold: accept if within reasonable distance (~width/6)
                    const acceptTh = Math.max(20, Math.min(width, height) / 6);
                    let regionLabel = null;
                    if (best && best.d <= acceptTh) {
                      // if already assigned, keep the closer one
                      if (!assigned[best.k] || assigned[best.k].dist > best.d) {
                        assigned[best.k] = { idx: i, dist: best.d };
                        regionLabel = best.ep.label;
                      } else {
                        regionLabel = best.ep.label; // still label but duplicates may exist, we'll resolve later
                      }
                    } else {
                      // fallback: use top/bottom row based on y
                      regionLabel =
                        cy < height / 2
                          ? cx < width / 2
                            ? "TM"
                            : "TR"
                          : cx < width / 2
                          ? "BM"
                          : "BR";
                    }

                    markerCount++;
                    innerAreas.push(childArea);
                    normalMarkers.push({
                      outerIdx: i,
                      innerIdx: childIdx,
                      innerArea: childArea,
                      cx: cx,
                      cy: cy,
                      label: regionLabel,
                    });

                    cv.drawContours(
                      dst,
                      contours,
                      i,
                      new cv.Scalar(0, 255, 0, 255),
                      2,
                      cv.LINE_8,
                      hierarchy,
                      0
                    );
                    cv.drawContours(
                      dst,
                      contours,
                      childIdx,
                      new cv.Scalar(0, 128, 255, 255),
                      2,
                      cv.LINE_8
                    );
                    cv.putText(
                      dst,
                      regionLabel,
                      new cv.Point(Math.round(cx) - 12, Math.round(cy) - 12),
                      cv.FONT_HERSHEY_SIMPLEX,
                      0.7,
                      new cv.Scalar(255, 255, 255, 255),
                      2
                    );
                  }
                  cApprox.delete();
                }
              }
            }
            approx.delete();
          }

          // Average inner area (use median to be robust)
          let avgInnerArea = 0;
          let medianInnerArea = 0;
          if (innerAreas.length > 0) {
            avgInnerArea =
              innerAreas.reduce((a, b) => a + b, 0) / innerAreas.length;
            // median
            let sorted = innerAreas.slice().sort((a, b) => a - b);
            let mid = Math.floor(sorted.length / 2);
            medianInnerArea =
              sorted.length % 2 !== 0
                ? sorted[mid]
                : (sorted[mid - 1] + sorted[mid]) / 2;
          }

          // Deduplicate markers: if multiple detected markers were assigned the
          // same expected label (e.g., BR twice), keep only the one closest to
          // the expected position. Also include unassigned markers that don't
          // conflict with chosen ones.
          (function dedupeAssignedMarkers() {
            const expectedLabels = expectedPositions.map((e) => e.label);
            const uniqueNormals = [];

            for (let k = 0; k < expectedPositions.length; k++) {
              const ep = expectedPositions[k];
              const candidates = normalMarkers.filter(
                (n) => n.label === ep.label
              );
              if (candidates.length === 0) continue;
              let best = candidates[0];
              let bestD = Math.hypot(best.cx - ep.x, best.cy - ep.y);
              for (let i = 1; i < candidates.length; i++) {
                const c = candidates[i];
                const d = Math.hypot(c.cx - ep.x, c.cy - ep.y);
                if (d < bestD) {
                  best = c;
                  bestD = d;
                }
              }
              uniqueNormals.push(best);
            }

            // Add any other normalMarkers that weren't chosen above (different labels)
            for (const n of normalMarkers) {
              const exists = uniqueNormals.some(
                (u) => u.cx === n.cx && u.cy === n.cy
              );
              if (!exists) {
                // If the label is one of the expected labels but wasn't chosen,
                // skip it; otherwise include it (fallback/labeled by y/x)
                if (!expectedLabels.includes(n.label)) uniqueNormals.push(n);
              }
            }

            normalMarkers = uniqueNormals;
            // update markerCount to reflect deduped normals
            markerCount = normalMarkers.length;
          })();

          // New special detection for layout with 7 markers:
          // Top row: TL, TM, E, TR (4 markers). Bottom row: BL, BM, BR (3 markers).
          // The special marker is the top marker that sits between TM and TR (label 'E')
          // and does NOT have a counterpart directly below it. We'll detect it by label
          // if assigned, otherwise by absence of a bottom marker under its x.
          let specialCount = 0;
          let specialsDetected = [];
          let specialMarker = null;

          const topMarkers = normalMarkers.filter((n) => n.cy < height / 2);
          const bottomMarkers = normalMarkers.filter((n) => n.cy >= height / 2);

          // Prefer explicit label 'E'
          specialMarker = normalMarkers.find((n) => n.label === "E");

          // Fallback: find a top marker without bottom counterpart (x-distance)
          if (!specialMarker && topMarkers.length >= 3) {
            const xTol = Math.max(20, width / 10);
            for (let t of topMarkers) {
              const hasBelow = bottomMarkers.some(
                (b) => Math.abs(b.cx - t.cx) < xTol
              );
              if (!hasBelow) {
                specialMarker = t;
                break;
              }
            }
          }

          if (specialMarker) {
            specialCount = 1;
            specialsDetected.push({
              type: "identified",
              cx: specialMarker.cx,
              cy: specialMarker.cy,
              label: specialMarker.label,
            });
            cv.drawContours(
              dst,
              contours,
              specialMarker.outerIdx,
              new cv.Scalar(255, 0, 0, 255),
              3,
              cv.LINE_8,
              hierarchy,
              0
            );
            cv.putText(
              dst,
              (specialMarker.label || "E") + "*",
              new cv.Point(
                Math.round(specialMarker.cx) - 16,
                Math.round(specialMarker.cy) - 16
              ),
              cv.FONT_HERSHEY_SIMPLEX,
              0.7,
              new cv.Scalar(255, 255, 255, 255),
              2
            );
            // remove from normalMarkers list
            normalMarkers = normalMarkers.filter(
              (n) => !(n.cx === specialMarker.cx && n.cy === specialMarker.cy)
            );
            markerCount = Math.max(0, markerCount - 1);
          }

          cv.putText(
            dst,
            "Normales: " + markerCount,
            new cv.Point(10, 30),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 255, 0, 255),
            2
          );
          cv.putText(
            dst,
            "Especiales: " + specialCount,
            new cv.Point(10, 60),
            cv.FONT_HERSHEY_SIMPLEX,
            1.0,
            new cv.Scalar(0, 0, 255, 255),
            2
          );

          cv.imshow("canvasOutput", dst);

          // If all 7 markers detected, capture last frame (with marks) once
          let totalDetected = markerCount + specialCount;
          if (totalDetected >= 7 && !captured) {
            captured = true;
            // prepare final lists
            let finalNormals = normalMarkers.slice();
            let special = null;
            // if specialMarker set, use it
            if (specialMarker) {
              special = specialMarker;
              if (special.from === "normal") {
                // remove the normal that became special
                let entry = specialsDetected.find(
                  (s) => s.type === "normalInner"
                );
                if (entry && typeof entry.idx === "number") {
                  finalNormals.splice(entry.idx, 1);
                }
              }
            } else if (
              specialsDetected.length > 0 &&
              specialsDetected[0].cx !== undefined
            ) {
              special = {
                cx: specialsDetected[0].cx,
                cy: specialsDetected[0].cy,
                label: null,
                from: "inverted",
              };
            } else {
              // fallback: promote BR (bottom-right fallback)
              let br = normalMarkers.find((n) => n.label === "BR");
              if (br) {
                special = {
                  cx: br.cx,
                  cy: br.cy,
                  label: "BR",
                  from: "promoted",
                };
                // remove br from normals
                finalNormals = finalNormals.filter(
                  (n) => !(n.cx === br.cx && n.cy === br.cy)
                );
              }
            }

            // capture canvas image
            const dataURL = canvas.toDataURL("image/png");

            // determine best rotation (0/90/180/270) so the special marker
            // lands close to the expected 'E' position (top row, 3rd slot).
            let rot = 0;
            if (special) {
              const angles = [0, 90, 180, 270];
              const cx0 = width / 2,
                cy0 = height / 2;
              function rotatePointForAngle(x, y, angle) {
                const a = (angle * Math.PI) / 180;
                // rotated canvas dims
                const rw = angle % 180 === 0 ? width : height;
                const rh = angle % 180 === 0 ? height : width;
                const newCx = rw / 2,
                  newCy = rh / 2;
                const tx = x - cx0,
                  ty = y - cy0;
                const rx = tx * Math.cos(a) - ty * Math.sin(a);
                const ry = tx * Math.sin(a) + ty * Math.cos(a);
                return { x: Math.round(rx + newCx), y: Math.round(ry + newCy) };
              }
              // expected E position relative to rotated canvas
              function expectedEForAngle(angle) {
                const rw = angle % 180 === 0 ? width : height;
                const rh = angle % 180 === 0 ? height : width;
                return { x: 0.625 * rw, y: 0.25 * rh };
              }
              let best = { angle: 0, dist: Infinity };
              for (let a of angles) {
                const rp = rotatePointForAngle(special.cx, special.cy, a);
                const ep = expectedEForAngle(a);
                const d = Math.hypot(rp.x - ep.x, rp.y - ep.y);
                if (d < best.dist) {
                  best = { angle: a, dist: d };
                }
              }
              rot = best.angle;
            }

            // show snapshot overlay
            createSnapshotOverlay(
              dataURL,
              rot,
              finalNormals,
              special,
              width,
              height
            );
          }

          // cleanup
          dst.delete();
          contours.delete();
          hierarchy.delete();

          if (!captured) requestAnimationFrame(loop);
        }

        function createSnapshotOverlay(
          dataURL,
          rotationDeg,
          normals,
          special,
          srcW,
          srcH
        ) {
          // remove existing overlay if any
          const existing = document.getElementById("omrSnapshotOverlay");
          if (existing) existing.remove();

          const overlay = document.createElement("div");
          overlay.id = "omrSnapshotOverlay";
          overlay.style.position = "fixed";
          overlay.style.left = "0";
          overlay.style.top = "0";
          overlay.style.width = "100%";
          overlay.style.height = "100%";
          overlay.style.display = "flex";
          overlay.style.alignItems = "center";
          overlay.style.justifyContent = "center";
          overlay.style.background = "rgba(0,0,0,0.8)";
          overlay.style.zIndex = 9999;

          const panel = document.createElement("div");
          panel.style.background = "#222";
          panel.style.padding = "12px";
          panel.style.borderRadius = "8px";
          panel.style.color = "#fff";
          panel.style.maxWidth = "95%";
          panel.style.maxHeight = "95%";
          panel.style.overflow = "auto";

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "Cerrar y continuar";
          closeBtn.style.marginBottom = "8px";
          closeBtn.onclick = () => {
            overlay.remove();
            // resume loop
            captured = false;
            try {
              loop();
            } catch (e) {
              /* ignore */
            }
          };

          const info = document.createElement("div");
          info.style.display = "flex";
          info.style.gap = "12px";

          const canvasWrap = document.createElement("div");
          const snapCanvas = document.createElement("canvas");
          snapCanvas.style.maxWidth = "80vw";
          snapCanvas.style.maxHeight = "80vh";
          canvasWrap.appendChild(snapCanvas);

          const list = document.createElement("div");
          list.style.minWidth = "220px";
          list.style.fontFamily = "monospace";

          const title = document.createElement("div");
          title.textContent = "Snapshot - coordenadas (px)";
          title.style.marginBottom = "8px";
          list.appendChild(title);

          const ul = document.createElement("ul");
          list.appendChild(ul);

          info.appendChild(canvasWrap);
          info.appendChild(list);
          panel.appendChild(closeBtn);
          panel.appendChild(info);
          overlay.appendChild(panel);
          document.body.appendChild(overlay);

          const img = new Image();
          img.onload = () => {
            // prepare canvas size according to rotation
            const angle = ((rotationDeg % 360) + 360) % 360;
            let dw = img.width,
              dh = img.height;
            if (angle === 90 || angle === 270) {
              snapCanvas.width = dh;
              snapCanvas.height = dw;
            } else {
              snapCanvas.width = dw;
              snapCanvas.height = dh;
            }
            const sctx = snapCanvas.getContext("2d");
            // clear
            sctx.fillStyle = "#000";
            sctx.fillRect(0, 0, snapCanvas.width, snapCanvas.height);
            // transform and draw
            sctx.save();
            sctx.translate(snapCanvas.width / 2, snapCanvas.height / 2);
            sctx.rotate((angle * Math.PI) / 180);
            sctx.drawImage(img, -img.width / 2, -img.height / 2);
            sctx.restore();

            // rotate points and draw markers + list
            const cx0 = srcW / 2,
              cy0 = srcH / 2;
            const newCx = snapCanvas.width / 2,
              newCy = snapCanvas.height / 2;
            const angleRad = (angle * Math.PI) / 180;
            function rotatePoint(x, y) {
              const tx = x - cx0;
              const ty = y - cy0;
              const rx = tx * Math.cos(angleRad) - ty * Math.sin(angleRad);
              const ry = tx * Math.sin(angleRad) + ty * Math.cos(angleRad);
              return { x: Math.round(rx + newCx), y: Math.round(ry + newCy) };
            }

            // draw normals and collect label mapping
            const labelMap = {};
            normals.forEach((n, idx) => {
              const rp = rotatePoint(n.cx, n.cy);
              labelMap[n.label] = rp;
              sctx.beginPath();
              sctx.arc(rp.x, rp.y, 6, 0, Math.PI * 2);
              sctx.fillStyle = "cyan";
              sctx.fill();
              sctx.fillStyle = "#fff";
              sctx.font = "14px monospace";
              sctx.fillText(n.label + ` (${rp.x},${rp.y})`, rp.x + 8, rp.y - 8);
              const li = document.createElement("li");
              li.textContent = `${n.label}: ${Math.round(n.cx)}, ${Math.round(
                n.cy
              )}`;
              ul.appendChild(li);
            });

            if (special) {
              const rp = rotatePoint(special.cx, special.cy);
              labelMap[special.label || "SPECIAL"] = rp;
              sctx.beginPath();
              sctx.arc(rp.x, rp.y, 8, 0, Math.PI * 2);
              sctx.fillStyle = "red";
              sctx.fill();
              sctx.fillStyle = "#fff";
              sctx.font = "16px monospace";
              sctx.fillText("SPECIAL", rp.x + 10, rp.y + 6);
              const li = document.createElement("li");
              li.textContent = `SPECIAL (${
                special.label || "unknown"
              }): ${Math.round(special.cx)}, ${Math.round(special.cy)}`;
              ul.appendChild(li);
            }

            // draw connection lines for visualization
            function drawLine(a, b, color) {
              if (a && b) {
                sctx.strokeStyle = color || "#0f0";
                sctx.lineWidth = 2;
                sctx.beginPath();
                sctx.moveTo(a.x, a.y);
                sctx.lineTo(b.x, b.y);
                sctx.stroke();
              }
            }
            drawLine(labelMap["TL"], labelMap["TM"], "#88f");
            drawLine(labelMap["TM"], labelMap["TR"], "#88f");
            drawLine(labelMap["BL"], labelMap["BM"], "#88f");
            drawLine(labelMap["BM"], labelMap["BR"], "#88f");
            drawLine(labelMap["TL"], labelMap["BL"], "#8f8");
            drawLine(labelMap["TM"], labelMap["BM"], "#8f8");
            drawLine(labelMap["TR"], labelMap["BR"], "#8f8");

            // If we have the four corners (TL,TR,BL,BR) perform perspective correction
            const required = ["TL", "TR", "BL", "BR"];
            const hasAll = required.every((l) => !!labelMap[l]);
            if (hasAll && typeof cv !== "undefined") {
              try {
                function dist(a, b) {
                  const dx = a.x - b.x,
                    dy = a.y - b.y;
                  return Math.hypot(dx, dy);
                }
                const topW = dist(labelMap["TL"], labelMap["TR"]);
                const botW = dist(labelMap["BL"], labelMap["BR"]);
                const leftH = dist(labelMap["TL"], labelMap["BL"]);
                const rightH = dist(labelMap["TR"], labelMap["BR"]);
                const dstW = Math.max(1, Math.round((topW + botW) / 2));
                const dstH = Math.max(1, Math.round((leftH + rightH) / 2));

                const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  labelMap["TL"].x,
                  labelMap["TL"].y,
                  labelMap["TR"].x,
                  labelMap["TR"].y,
                  labelMap["BL"].x,
                  labelMap["BL"].y,
                  labelMap["BR"].x,
                  labelMap["BR"].y,
                ]);
                const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                  0,
                  0,
                  dstW,
                  0,
                  0,
                  dstH,
                  dstW,
                  dstH,
                ]);

                let srcMat = cv.imread(snapCanvas);
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                let dstMat = new cv.Mat();
                let dsize = new cv.Size(dstW, dstH);
                cv.warpPerspective(
                  srcMat,
                  dstMat,
                  M,
                  dsize,
                  cv.INTER_LINEAR,
                  cv.BORDER_CONSTANT,
                  new cv.Scalar()
                );

                const corrected = document.createElement("canvas");
                corrected.width = dstW;
                corrected.height = dstH;
                corrected.style.maxWidth = "80vw";
                corrected.style.display = "block";
                const corrWrap = document.createElement("div");
                corrWrap.style.marginTop = "8px";
                corrWrap.appendChild(corrected);
                canvasWrap.appendChild(corrWrap);
                cv.imshow(corrected, dstMat);

                // draw small marker at corners for visual check
                const cctx = corrected.getContext("2d");
                cctx.fillStyle = "red";
                cctx.beginPath();
                cctx.arc(6, 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(dstW - 6, 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(6, dstH - 6, 5, 0, Math.PI * 2);
                cctx.fill();
                cctx.beginPath();
                cctx.arc(dstW - 6, dstH - 6, 6, 0, Math.PI * 2);
                cctx.fill();

                // cleanup
                srcTri.delete();
                dstTri.delete();
                srcMat.delete();
                M.delete();
                dstMat.delete();
              } catch (err) {
                console.error("Persp transform failed", err);
              }
            }
          };
          img.src = dataURL;
        }

        loop();
      }
    </script>
  </body>
</html>
